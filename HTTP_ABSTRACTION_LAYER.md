# HTTP Abstraction Layer

**Status:** Draft | **Version:** 0.1.0

---

## Problem Statement

Traditional "framework-independent" architectures stop at the use case boundary. The framework adapter handles:
- HTTP routing
- Request parameter extraction and validation
- Request body deserialization
- Response serialization
- HTTP status code mapping
- Content negotiation

When switching frameworks (Spring → Micronaut, JAX-RS → Ktor), all this code must be rewritten. Testing requires framework-specific test infrastructure. Business logic is framework-independent, but the HTTP layer is not.

**The cost:**
- Every framework change rewrites routing, serialization, error mapping
- HTTP logic tested through framework-specific test harness
- Cannot test routing, parameter extraction, error responses without running framework
- Duplicate validation logic (HTTP layer validates, then use case validates)

---

## Solution: Framework-Independent HTTP Abstraction

Move routing, deserialization, serialization, and error mapping into framework-independent code. Framework adapter becomes a thin translation layer:

**Framework adapter responsibility:**
```java
@RestController
public class SpringAdapter {
    private final HttpRouter router;
    private final RequestFactory requestFactory;

    @RequestMapping("/**")
    public ResponseEntity<?> route(HttpServletRequest request) {
        return requestFactory.newRequest()
                            .method(request.getMethod())
                            .path(request.getRequestURI())
                            .headers(extractHeaders(request))
                            .queryParams(extractQueryParams(request))
                            .body(request.getInputStream())
                            .build()
                            .async()
                            .flatMap(router::route)
                            .await()
                            .map(this::toResponseEntity)
                            .orElse(ResponseEntity.status(500).build());
    }

    private ResponseEntity<?> toResponseEntity(HttpResponse response) {
        return ResponseEntity
            .status(response.status())
            .headers(toSpringHeaders(response.headers()))
            .body(response.body());
    }
}
```

Everything else (routing, deserialization, error mapping, serialization) is framework-independent and testable without Spring.

---

## Core Components

### HttpRequest

Immutable request representation created by framework adapter:

```java
public record HttpRequest(
    String requestId,           // Generated by RequestFactory
    String method,              // GET, POST, etc.
    String path,                // /api/v1/users/123
    Map<String, String> headers,
    Map<String, List<String>> queryParams,
    byte[] body
) {
    // Typed access helpers
    public Option<String> header(String name) { ... }
    public Option<String> queryParam(String name) { ... }
    public <T> Result<T> body(Class<T> type) { ... }
    public <T> Result<T> body(TypeToken<T> type) { ... }
}
```

### HttpResponse

Immutable response representation returned to framework adapter:

```java
public record HttpResponse(
    String requestId,
    int status,
    Map<String, List<String>> headers,
    byte[] body
) {
    public static HttpResponse ok(String requestId, byte[] body) { ... }
    public static HttpResponse created(String requestId, byte[] body) { ... }
    public static HttpResponse noContent(String requestId) { ... }
}
```

### RequestFactory

Generates unique request IDs and creates RequestBuilder:

```java
public interface RequestFactory {
    RequestBuilder newRequest();

    static RequestFactory requestFactory(IdProvider idProvider) {
        return () -> RequestBuilder.builder(idProvider.generateId());
    }
}

@FunctionalInterface
public interface IdProvider {
    String generateId();
}
```

### RequestBuilder

Fluent builder for constructing HttpRequest with pre-assigned requestId:

```java
public final class RequestBuilder {
    private final String requestId;  // Set in constructor, immutable
    private String method;
    private String path;
    private Map<String, String> headers = new HashMap<>();
    private Map<String, List<String>> queryParams = new HashMap<>();
    private byte[] body = new byte[0];

    private RequestBuilder(String requestId) {
        this.requestId = requestId;
    }

    static RequestBuilder builder(String requestId) {
        return new RequestBuilder(requestId);
    }

    public String requestId() {
        return requestId;
    }

    public RequestBuilder method(String method) {
        this.method = method;
        return this;
    }

    public RequestBuilder path(String path) {
        this.path = path;
        return this;
    }

    public RequestBuilder header(String name, String value) {
        this.headers.put(name, value);
        return this;
    }

    public RequestBuilder headers(Map<String, String> headers) {
        this.headers.putAll(headers);
        return this;
    }

    public RequestBuilder queryParam(String name, String value) {
        this.queryParams.computeIfAbsent(name, k -> new ArrayList<>()).add(value);
        return this;
    }

    public RequestBuilder queryParams(Map<String, List<String>> params) {
        this.queryParams.putAll(params);
        return this;
    }

    public RequestBuilder body(byte[] body) {
        this.body = body;
        return this;
    }

    public RequestBuilder body(InputStream inputStream) {
        this.body = inputStream.readAllBytes();
        return this;
    }

    public Result<HttpRequest> build() {
        return Verify.ensure(method, Verify.Is::notNull)
                     .flatMap(_ -> Verify.ensure(path, Verify.Is::notNull))
                     .map(_ -> new HttpRequest(
                         requestId,
                         method,
                         path,
                         Map.copyOf(headers),
                         Map.copyOf(queryParams),
                         body
                     ));
    }
}
```

**Key characteristic:** `requestId` is generated by RequestFactory and cannot be modified. Framework adapter has no control over it.

### ResponseBuilder

Mutable builder for assembling HttpResponse:

```java
public final class ResponseBuilder {
    private final String requestId;
    private int status = 200;
    private final Map<String, List<String>> headers = new HashMap<>();
    private byte[] body = new byte[0];

    private ResponseBuilder(String requestId) {
        this.requestId = requestId;
    }

    public static ResponseBuilder builder(String requestId) {
        return new ResponseBuilder(requestId);
    }

    public String requestId() {
        return requestId;
    }

    public ResponseBuilder status(int status) {
        this.status = status;
        return this;
    }

    public ResponseBuilder header(String name, String value) {
        this.headers.computeIfAbsent(name, k -> new ArrayList<>()).add(value);
        return this;
    }

    public ResponseBuilder contentType(String mimeType) {
        return header("Content-Type", mimeType);
    }

    public ResponseBuilder json(Object obj) {
        this.body = JsonSerializer.serialize(obj);
        return contentType("application/json");
    }

    public ResponseBuilder body(byte[] body) {
        this.body = body;
        return this;
    }

    public HttpResponse build() {
        return new HttpResponse(
            requestId,
            status,
            Map.copyOf(headers),
            body
        );
    }
}
```

---

## Routing API

### Three-Stage Fluent Builder

Route definition follows three distinct stages:

**Stage 1: Path Definition** (no parameters yet)
- `.path(String segment)` - Add path segment (can contain multiple levels: `"api/v1"`)
- `.subpath(Route... routes)` - Define nested routes (terminal operation)

**Stage 2: Parameter Collection** (after first param/query/body)
- `.path(String segment)` - Still allowed (e.g., `.param(id).path("orders")`)
- `.param(Class<T> type)` - Path parameter (adds `Option<T>` to handler signature)
- `.param(TypeToken<T> type)` - Path parameter with generic type
- `.queryParam(String name, Class<T> type)` - Query parameter
- `.body(Class<T> type)` - Request body

**Stage 3: Handler Description** (after HTTP method)
- `.get()` / `.post()` / `.put()` / `.delete()` / `.patch()` - HTTP method
- `.in(String mimeType)` - Request content type (optional, defaults to `application/json`)
- `.out(String mimeType)` - Response content type (optional, defaults to `application/json`)
- `.handler(Function)` - Terminal operation, receives collected parameters

### Basic Route Examples

**No parameters:**
```java
Route.path("api/v1/health")
     .get()
     .handler(() -> Promise.success(new HealthStatus("OK")))
```

**Single path parameter:**
```java
Route.path("api/v1/users")
     .param(UserId.class)
     .get()
     .handler((Option<UserId> userId) ->
         getUserUseCase.execute(userId))
```

**Multiple path parameters:**
```java
Route.path("api/v1/users")
     .param(UserId.class)
     .path("orders")
     .param(OrderId.class)
     .get()
     .handler((Option<UserId> userId, Option<OrderId> orderId) ->
         getOrderUseCase.execute(userId, orderId))
```

**Query parameters:**
```java
Route.path("api/v1/users")
     .queryParam("status", UserStatus.class)
     .queryParam("role", UserRole.class)
     .get()
     .handler((Option<UserStatus> status, Option<UserRole> role) ->
         listUsersUseCase.execute(status, role))
```

**Request body:**
```java
Route.path("api/v1/users")
     .body(CreateUserRequest.class)
     .post()
     .in("application/json")
     .out("application/json")
     .handler((Option<CreateUserRequest> request) ->
         createUserUseCase.execute(request))
```

**Mixed parameters:**
```java
Route.path("api/v1/users")
     .param(UserId.class)
     .queryParam("includeOrders", Boolean.class)
     .body(UpdateUserRequest.class)
     .put()
     .handler((Option<UserId> userId,
               Option<Boolean> includeOrders,
               Option<UpdateUserRequest> request) ->
         updateUserUseCase.execute(userId, includeOrders, request))
```

### Nested Routes with Subpath

```java
Route.path("api/v1/users")
     .subpath(
         // GET /api/v1/users/{userId}
         Route.param(UserId.class)
              .get()
              .handler((Option<UserId> id) ->
                  getUserUseCase.execute(id)),

         // POST /api/v1/users
         Route.body(CreateUserRequest.class)
              .post()
              .handler((Option<CreateUserRequest> req) ->
                  createUserUseCase.execute(req)),

         // DELETE /api/v1/users/{userId}
         Route.param(UserId.class)
              .delete()
              .handler((Option<UserId> id) ->
                  deleteUserUseCase.execute(id))
     )
```

**Key rules:**
- `.subpath()` only available in Stage 1 (before any parameters)
- HTTP method comes after all parameters (transitions to Stage 3)
- Handler signature matches collected parameters in order
- All parameters are `Option<T>` (may be absent)

---

## Serialization and Deserialization

### JsonSerializer and JsonDeserializer

Abstract JSON operations behind interfaces:

```java
public interface JsonSerializer {
    byte[] serialize(Object obj);

    static JsonSerializer jackson() {
        return obj -> {
            try {
                return objectMapper.writeValueAsBytes(obj);
            } catch (JsonProcessingException e) {
                throw new SerializationException(e);
            }
        };
    }
}

public interface JsonDeserializer {
    <T> Result<T> deserialize(byte[] json, Class<T> type);
    <T> Result<T> deserialize(byte[] json, TypeToken<T> type);

    static JsonDeserializer jackson() {
        return new JsonDeserializer() {
            public <T> Result<T> deserialize(byte[] json, Class<T> type) {
                return Result.lift(() -> objectMapper.readValue(json, type));
            }

            public <T> Result<T> deserialize(byte[] json, TypeToken<T> type) {
                return Result.lift(() ->
                    objectMapper.readValue(json, type.getType()));
            }
        };
    }
}
```

**Usage in HttpRequest:**
```java
public <T> Result<T> body(Class<T> type) {
    return deserializer.deserialize(this.body, type);
}
```

**Usage in ResponseBuilder:**
```java
public ResponseBuilder json(Object obj) {
    this.body = serializer.serialize(obj);
    return contentType("application/json");
}
```

**Default:** Jackson for both serialization and deserialization. Pluggable for alternatives (Gson, Moshi, custom).

---

## Error Handling with RFC 7807

### HttpStatusCause Interface

Business errors implement `HttpStatusCause` to provide HTTP-specific error details:

```java
public interface HttpStatusCause extends Cause {
    int httpStatus();
    void fillResponse(ResponseBuilder builder);
}
```

### RFC 7807: Problem Details for HTTP APIs

Error responses follow [RFC 7807](https://datatracker.ietf.org/doc/html/rfc7807) standard:

**Required fields:**
- `type` - URI reference identifying the problem type
- `title` - Short, human-readable summary
- `status` - HTTP status code
- `request-id` - Unique request identifier for correlation

**Optional fields:**
- `detail` - Human-readable explanation specific to this occurrence
- `instance` - URI reference identifying the specific occurrence

### Error Enum Pattern

```java
public enum UserError implements HttpStatusCause {
    EMAIL_ALREADY_EXISTS(409, "email_exists", "Email address is already registered"),
    INVALID_EMAIL(400, "invalid_email", "Email address format is invalid"),
    USER_NOT_FOUND(404, "user_not_found", "User not found"),
    ACCOUNT_LOCKED(403, "account_locked", "Account is temporarily locked");

    private final int status;
    private final String type;
    private final String title;

    UserError(int status, String type, String title) {
        this.status = status;
        this.type = type;
        this.title = title;
    }

    @Override
    public int httpStatus() {
        return status;
    }

    @Override
    public void fillResponse(ResponseBuilder builder) {
        builder.status(status)
               .contentType("application/problem+json")
               .json(Map.of(
                   "type", type,
                   "title", title,
                   "status", status,
                   "request-id", builder.requestId()
               ));
    }

    @Override
    public String message() {
        return title;
    }
}
```

### Error with Variable Data

For errors requiring instance-specific data:

```java
public sealed interface OrderError extends HttpStatusCause {
    enum InsufficientStock implements OrderError {
        INSTANCE;

        @Override
        public int httpStatus() { return 409; }

        @Override
        public void fillResponse(ResponseBuilder builder) {
            builder.status(409)
                   .contentType("application/problem+json")
                   .json(Map.of(
                       "type", "insufficient_stock",
                       "title", "Insufficient stock for order",
                       "status", 409,
                       "request-id", builder.requestId()
                   ));
        }

        @Override
        public String message() { return "Insufficient stock"; }
    }

    record InvalidQuantity(int requested, int maximum) implements OrderError {
        @Override
        public int httpStatus() { return 400; }

        @Override
        public void fillResponse(ResponseBuilder builder) {
            builder.status(400)
                   .contentType("application/problem+json")
                   .json(Map.of(
                       "type", "invalid_quantity",
                       "title", "Order quantity exceeds maximum allowed",
                       "status", 400,
                       "detail", "Requested " + requested + " but maximum is " + maximum,
                       "request-id", builder.requestId()
                   ));
        }

        @Override
        public String message() {
            return "Invalid quantity: requested " + requested + ", max " + maximum;
        }
    }
}
```

### Automatic Error Response Generation

Route builder automatically converts `HttpStatusCause` failures to HTTP responses:

```java
Route.path("api/v1/users")
     .param(UserId.class)
     .get()
     .handler((Option<UserId> userId) ->
         getUserUseCase.execute(userId)
             // If execute returns Promise.failure(UserError.USER_NOT_FOUND)
             // Route builder calls fillResponse() automatically
     )
```

**Internal transformation:**
```java
handler.apply(params)
       .recover(cause -> {
           if (cause instanceof HttpStatusCause httpCause) {
               var builder = ResponseBuilder.builder(requestId);
               httpCause.fillResponse(builder);
               return builder.build();
           }
           // Fallback for non-HTTP causes
           return ResponseBuilder.builder(requestId)
                                .status(500)
                                .contentType("application/problem+json")
                                .json(Map.of(
                                    "type", "internal_error",
                                    "title", "Internal server error",
                                    "status", 500,
                                    "request-id", requestId
                                ))
                                .build();
       })
```

---

## Request ID Flow and Logging

### Request ID Generation

Request ID is generated at the entry point and flows through entire request lifecycle:

```java
// 1. Framework adapter creates request with ID
RequestFactory factory = RequestFactory.requestFactory(
    () -> "req_" + UUID.randomUUID().toString()
);

HttpRequest request = factory.newRequest()
                             .method("POST")
                             .path("/api/v1/users")
                             .build()
                             .orElseThrow();

// 2. Request ID available throughout processing
String requestId = request.requestId();

// 3. Response includes same ID in headers
HttpResponse response = ResponseBuilder.builder(request.requestId())
                                      .status(200)
                                      .json(data)
                                      .build();

// 4. Error responses include ID in RFC 7807 body
{
  "type": "user_not_found",
  "title": "User not found",
  "status": 404,
  "request-id": "req_1a2b3c4d"
}
```

### Logging Strategy

Logging follows structured levels with request ID correlation:

**Entry point (HTTP handler):**
```
INFO:  Request received [request-id: req_1a2b3c4d, method: POST, path: /api/v1/users]
ERROR: Request failed [request-id: req_1a2b3c4d, error: email_exists, status: 409]
INFO:  Response sent [request-id: req_1a2b3c4d, status: 201, duration: 145ms]
```

**Mid-layer (steps, validation):**
```
DEBUG: Validating email [request-id: req_1a2b3c4d, email: user@example.com]
DEBUG: Checking email uniqueness [request-id: req_1a2b3c4d]
DEBUG: Email validation passed [request-id: req_1a2b3c4d]
```

**Business logic (use case execute):**
```
TRACE: UseCase input [request-id: req_1a2b3c4d, useCase: RegisterUser, input: {...}]
TRACE: UseCase output [request-id: req_1a2b3c4d, useCase: RegisterUser, output: {...}]
```

**Logging levels:**
- **ERROR**: Exceptions, use case failures returning `Cause`
- **INFO**: Request received, response sent (with requestId, duration)
- **DEBUG**: Step execution, validation results, intermediate processing
- **TRACE**: Business logic input/output (sensitive data, verbose)

**Benefits:**
- Request-response correlation in asynchronous systems
- Trace complete request flow across logs
- Focused logging: errors at entry point, details at deeper levels
- Production debugging without exposing business logic at INFO level

---

## Complete Example: User Registration

### Use Case

```java
public interface RegisterUser extends UseCase.WithPromise<RegisterUser.Response, RegisterUser.Request> {
    record Request(String email, String password) {}
    record Response(UserId userId, String email) {}

    interface CheckEmailUniqueness {
        Promise<ValidRequest> apply(ValidRequest request);
    }

    interface HashPassword {
        Result<HashedPassword> apply(Password password);
    }

    interface SaveUser {
        Promise<UserId> apply(ValidatedUser user);
    }

    record ValidRequest(Email email, Password password) {
        static Result<ValidRequest> validRequest(Request request) {
            return Result.all(Email.email(request.email()),
                              Password.password(request.password()))
                         .map(ValidRequest::new);
        }
    }

    record ValidatedUser(Email email, HashedPassword hashedPassword) {}

    static RegisterUser registerUser(CheckEmailUniqueness checkEmail,
                                     HashPassword hashPassword,
                                     SaveUser saveUser) {
        return request -> ValidRequest.validRequest(request)
            .async()
            .flatMap(checkEmail::apply)
            .flatMap(valid -> hashPassword.apply(valid.password())
                .async()
                .map(hashed -> new ValidatedUser(valid.email(), hashed)))
            .flatMap(saveUser::apply)
            .map(userId -> new Response(userId, request.email()));
    }
}
```

### Error Definitions

```java
public enum RegistrationError implements HttpStatusCause {
    EMAIL_ALREADY_EXISTS(409, "email_exists", "Email address is already registered"),
    WEAK_PASSWORD(400, "weak_password", "Password does not meet security requirements"),
    INVALID_EMAIL(400, "invalid_email", "Email address format is invalid");

    private final int status;
    private final String type;
    private final String title;

    RegistrationError(int status, String type, String title) {
        this.status = status;
        this.type = type;
        this.title = title;
    }

    @Override
    public int httpStatus() { return status; }

    @Override
    public void fillResponse(ResponseBuilder builder) {
        builder.status(status)
               .contentType("application/problem+json")
               .json(Map.of(
                   "type", type,
                   "title", title,
                   "status", status,
                   "request-id", builder.requestId()
               ));
    }

    @Override
    public String message() { return title; }
}
```

### HTTP Handler

```java
public class UserHttpHandler {
    private final RegisterUser registerUser;

    public UserHttpHandler(RegisterUser registerUser) {
        this.registerUser = registerUser;
    }

    public HttpRouter routes() {
        return HttpRouter.router(
            Route.path("api/v1/users")
                 .body(RegisterUser.Request.class)
                 .post()
                 .in("application/json")
                 .out("application/json")
                 .handler(this::handleRegister)
        );
    }

    private Promise<RegisterUser.Response> handleRegister(Option<RegisterUser.Request> request) {
        return request.toResult(RegistrationError.INVALID_EMAIL)
                      .async()
                      .flatMap(registerUser::execute);
    }
}
```

### Framework Adapter (Spring)

```java
@RestController
public class SpringAdapter {
    private final HttpRouter router;
    private final RequestFactory requestFactory;

    public SpringAdapter(RegisterUser registerUser) {
        this.requestFactory = RequestFactory.requestFactory(
            () -> "req_" + UUID.randomUUID().toString()
        );
        this.router = new UserHttpHandler(registerUser).routes();
    }

    @RequestMapping(value = "/**", method = {RequestMethod.GET, RequestMethod.POST,
                                             RequestMethod.PUT, RequestMethod.DELETE})
    public ResponseEntity<?> route(HttpServletRequest request) throws IOException {
        return requestFactory.newRequest()
            .method(request.getMethod())
            .path(request.getRequestURI())
            .headers(extractHeaders(request))
            .queryParams(extractQueryParams(request))
            .body(request.getInputStream())
            .build()
            .async()
            .flatMap(router::route)
            .await()
            .map(this::toResponseEntity)
            .orElse(ResponseEntity.status(500).build());
    }

    private Map<String, String> extractHeaders(HttpServletRequest request) {
        Map<String, String> headers = new HashMap<>();
        Collections.list(request.getHeaderNames())
                   .forEach(name -> headers.put(name, request.getHeader(name)));
        return headers;
    }

    private Map<String, List<String>> extractQueryParams(HttpServletRequest request) {
        return request.getParameterMap().entrySet().stream()
            .collect(Collectors.toMap(
                Map.Entry::getKey,
                e -> Arrays.asList(e.getValue())
            ));
    }

    private ResponseEntity<?> toResponseEntity(HttpResponse response) {
        HttpHeaders headers = new HttpHeaders();
        response.headers().forEach((name, values) ->
            headers.addAll(name, values));

        return ResponseEntity
            .status(response.status())
            .headers(headers)
            .body(response.body());
    }
}
```

### Testing

**Pure HTTP layer test (no framework):**
```java
@Test
void handleRegister_succeeds_forValidRequest() {
    RegisterUser registerUser = request ->
        Promise.success(new RegisterUser.Response(
            new UserId("user-123"),
            request.email()
        ));

    var handler = new UserHttpHandler(registerUser);
    var request = RequestFactory.requestFactory(() -> "test-req-1")
                                .newRequest()
                                .method("POST")
                                .path("/api/v1/users")
                                .body("{\"email\":\"user@example.com\",\"password\":\"Secret123\"}")
                                .build()
                                .orElseThrow();

    handler.routes()
           .route(request)
           .await()
           .onFailure(Assertions::fail)
           .onSuccess(response -> {
               assertEquals(201, response.status());
               assertTrue(response.body().length > 0);
           });
}

@Test
void handleRegister_fails_forDuplicateEmail() {
    RegisterUser registerUser = request ->
        RegistrationError.EMAIL_ALREADY_EXISTS.promise();

    var handler = new UserHttpHandler(registerUser);
    var request = RequestFactory.requestFactory(() -> "test-req-2")
                                .newRequest()
                                .method("POST")
                                .path("/api/v1/users")
                                .body("{\"email\":\"existing@example.com\",\"password\":\"Secret123\"}")
                                .build()
                                .orElseThrow();

    handler.routes()
           .route(request)
           .await()
           .onFailure(Assertions::fail)
           .onSuccess(response -> {
               assertEquals(409, response.status());
               assertEquals("application/problem+json",
                          response.headers().get("Content-Type").get(0));
               // Verify RFC 7807 body contains request-id
               String body = new String(response.body());
               assertTrue(body.contains("\"request-id\":\"test-req-2\""));
           });
}
```

**Framework adapter test:**
```java
@SpringBootTest
@AutoConfigureMockMvc
class SpringAdapterTest {
    @Autowired
    private MockMvc mockMvc;

    @Test
    void register_succeeds_forValidRequest() throws Exception {
        mockMvc.perform(post("/api/v1/users")
                   .contentType("application/json")
                   .content("{\"email\":\"user@example.com\",\"password\":\"Secret123\"}"))
               .andExpect(status().isCreated())
               .andExpect(jsonPath("$.userId").exists());
    }
}
```

---

## Benefits

### Framework Independence

**Before (traditional adapter):**
```java
@RestController
@RequestMapping("/api/v1/users")
public class UserController {
    private final RegisterUser registerUser;

    @PostMapping
    public ResponseEntity<?> register(@RequestBody @Valid RegisterRequest request) {
        try {
            var response = registerUser.execute(
                new RegisterUser.Request(request.email(), request.password())
            ).await();

            return response.match(
                success -> ResponseEntity.status(201).body(success),
                cause -> toErrorResponse(cause)
            );
        } catch (Exception e) {
            return ResponseEntity.status(500)
                .body(Map.of("error", "Internal server error"));
        }
    }

    private ResponseEntity<?> toErrorResponse(Cause cause) {
        return switch (cause) {
            case RegistrationError.EMAIL_ALREADY_EXISTS _ ->
                ResponseEntity.status(409)
                    .body(Map.of("error", "email_exists"));
            case RegistrationError.WEAK_PASSWORD _ ->
                ResponseEntity.status(400)
                    .body(Map.of("error", "weak_password"));
            default ->
                ResponseEntity.status(500)
                    .body(Map.of("error", "internal_error"));
        };
    }
}
```

**After (HTTP abstraction layer):**
```java
@RestController
public class SpringAdapter {
    private final HttpRouter router;
    private final RequestFactory requestFactory;

    @RequestMapping("/**")
    public ResponseEntity<?> route(HttpServletRequest request) {
        return requestFactory.newRequest()
            .method(request.getMethod())
            .path(request.getRequestURI())
            .build()
            .async()
            .flatMap(router::route)
            .await()
            .map(this::toResponseEntity)
            .orElse(ResponseEntity.status(500).build());
    }
}
```

**Switching from Spring to Micronaut:**
- Rewrite: 20 lines (adapter mapping only)
- Keep unchanged: Routing, deserialization, error mapping, serialization, logging

### Testability

**HTTP layer tests (no framework needed):**
- Test routing logic independently
- Test parameter extraction and validation
- Test error response formatting (RFC 7807)
- Test request ID flow
- Fast, pure unit tests

**Framework adapter tests (minimal):**
- Verify framework request → HttpRequest conversion
- Verify HttpResponse → framework response conversion
- Integration smoke tests only

### Maintainability

**Routing changes:**
- Update route definitions in one place
- Tests update automatically (route changes visible in test compilation)
- No grep-driven refactoring across controllers

**Serialization format changes:**
- Swap JsonSerializer/JsonDeserializer implementation
- All endpoints updated simultaneously
- Tests verify serialization format once

**Error response format changes:**
- Update HttpStatusCause.fillResponse() implementation
- RFC 7807 compliance verified in one place
- All error responses updated consistently

---

## Design Patterns

### addParam Delegation Pattern

**Problem:** Each PathStage interface (PathStage0-PathStage8) defines 5 parameter types × 2 method variants (Class/TypeToken) = 10 methods. With 9 stages and 9 RouteBuilder implementations, this results in ~900 lines of duplicate parameter method implementations.

**Solution:** Consolidate all parameter methods into a single `addParam(ParameterType, String, TypeToken)` method. All parameter methods delegate to this single implementation.

**Interface Pattern:**
```java
interface PathStage2<T1, T2> extends Route<HandlerStage2<T1, T2>> {
    PathStage2<T1, T2> path(String segment);

    /// Internal method - implementations must provide this
    <T3> PathStage3<T1, T2, T3> addParam(ParameterType type, String name, TypeToken<T3> token);

    // All parameter methods delegate to addParam
    default <T3> PathStage3<T1, T2, T3> param(TypeToken<T3> type) {
        return addParam(ParameterType.PATH, null, type);
    }

    default <T3> PathStage3<T1, T2, T3> queryParam(String name, TypeToken<T3> type) {
        return addParam(ParameterType.QUERY, name, type);
    }

    default <T3> PathStage3<T1, T2, T3> headerParam(HttpHeaderName name, TypeToken<T3> type) {
        return addParam(ParameterType.HEADER, name.headerName(), type);
    }

    default <T3> PathStage3<T1, T2, T3> cookieParam(String name, TypeToken<T3> type) {
        return addParam(ParameterType.COOKIE, name, type);
    }

    default <T3> PathStage3<T1, T2, T3> body(TypeToken<T3> type) {
        return addParam(ParameterType.BODY, null, type);
    }

    // Class<T> overloads delegate to TypeToken versions
    default <T3> PathStage3<T1, T2, T3> param(Class<T3> type) {
        return param(TypeToken.of(type));
    }
    // ... other Class<T> overloads
}
```

**Implementation Pattern:**
```java
final class RouteBuilder2<T1, T2> implements Route.PathStage2<T1, T2> {
    // ... fields

    @Override
    public <T3> Route.PathStage3<T1, T2, T3> addParam(ParameterType type, String name, TypeToken<T3> token) {
        var newParams = new ArrayList<>(parameters);
        newParams.add(new ParameterSpec(type, name, token));
        return new RouteBuilder3<>(pathSegments, newParams);
    }

    // No other parameter method implementations needed!
    // All 10 parameter methods inherited as defaults from PathStage2
}
```

**Benefits:**
- **90% code reduction:** RouteBuilder2-8 reduced from ~175 lines to ~122 lines each
- **Single implementation:** Each builder implements only `addParam()`, inherits 10 parameter methods as defaults
- **Type safety:** Compiler enforces correct return types (PathStage3, PathStage4, etc.)
- **Maintainability:** Changes to parameter handling logic require updating only one method per builder
- **Consistency:** All parameter types use identical delegation pattern

**Impact:**
- **Before refactoring:** 9 RouteBuilders × ~60 lines of parameter methods = ~540 lines
- **After refactoring:** 9 RouteBuilders × ~6 lines of addParam = ~54 lines
- **Net reduction:** ~490 lines eliminated, 223 lines saved in commit

**Related Pattern:** TypeToken delegation pattern - `Class<T>` overloads delegate to `TypeToken<T>` versions via `TypeToken.of(type)`.

---

### method() Delegation Pattern

**Problem:** Each RouteBuilder (RouteBuilder0-9) implements 5 HTTP method setters (get/post/put/delete/patch) with identical logic: set the method field and return `this`. With 10 builders, this results in 50 duplicate method implementations.

**Solution:** Add single `method(HttpMethod)` method to Route base interface. All HTTP method setters become default methods delegating to `method()`.

**Interface Pattern:**
```java
public interface Route<T extends Route<?>> extends RouteMatcher {
    /// Internal method - implementations must provide this
    T method(HttpMethod httpMethod);

    // All HTTP methods delegate to method()
    default T get() {
        return method(HttpMethod.GET);
    }

    default T post() {
        return method(HttpMethod.POST);
    }

    default T put() {
        return method(HttpMethod.PUT);
    }

    default T delete() {
        return method(HttpMethod.DELETE);
    }

    default T patch() {
        return method(HttpMethod.PATCH);
    }
}
```

**Implementation Pattern:**
```java
final class RouteBuilder2<T1, T2> implements Route.PathStage2<T1, T2> {
    private HttpMethod method;

    @Override
    public RouteBuilder2<T1, T2> method(HttpMethod httpMethod) {
        this.method = httpMethod;
        return this;
    }

    // No other HTTP method implementations needed!
    // All 5 methods inherited as defaults from Route
}
```

**Benefits:**
- **80% code reduction:** Each builder reduced by ~20 lines (5 methods × 4 lines each)
- **Single implementation:** Each builder implements only `method()`, inherits 5 HTTP methods as defaults
- **Type safety:** F-bounded polymorphism ensures correct return types
- **Extensibility:** Adding new HTTP methods (HEAD, OPTIONS) requires updating only base interface

**Impact:**
- **Before refactoring:** 10 RouteBuilders × 5 methods × ~5 lines = ~250 lines
- **After refactoring:** 10 RouteBuilders × 1 method × ~4 lines = ~40 lines
- **Net reduction:** ~210 lines eliminated, 224 lines saved in commit

**Combined with addParam pattern:**
- RouteBuilder1-8 reduced from ~175 lines to ~98 lines each (~44% final size)
- Total savings: ~490 lines (addParam) + ~224 lines (method) = ~714 lines eliminated

---

## Open Questions

1. **Authentication/Authorization** - Where do auth concerns live?
   - Per-route auth requirements?
   - Pre-handler auth checks?
   - Auth as aspect decorator?

2. **Request/Response interceptors** - How to add cross-cutting HTTP concerns?
   - CORS headers
   - Request logging
   - Response compression

3. **Multipart form data** - How to handle file uploads?
   - `.body()` insufficient for multipart
   - Separate `.multipart()` API?

4. **Streaming responses** - Large response bodies?
   - Current design assumes byte[] response
   - Stream API for chunked responses?

5. **WebSocket support** - Out of scope or future extension?

---

## References

- **RFC 7807: Problem Details for HTTP APIs** - https://datatracker.ietf.org/doc/html/rfc7807
- **Java Backend Coding Technology** - CODING_GUIDE.md
- **Pragmatica Lite Core** - https://github.com/siy/pragmatica-lite

---

**Document Version:** 0.1.0 (2025-01-10)
**Status:** Draft - Not for publication
**Copyright © 2025 Sergiy Yevtushenko. Released under the MIT License.**
