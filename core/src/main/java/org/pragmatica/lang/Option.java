/*
 *  Copyright (c) 2020-2025 Sergiy Yevtushenko.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package org.pragmatica.lang;

import org.pragmatica.lang.Functions.*;
import org.pragmatica.lang.Option.None;
import org.pragmatica.lang.Option.Some;
import org.pragmatica.lang.io.CoreError;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.function.Consumer;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.stream.Stream;

import static org.pragmatica.lang.Tuple.tuple;

/// Implementation of the basic immutable container for value which may or may not be present.
///
/// @param <T> Type of contained value
@SuppressWarnings("unused")
public sealed interface Option<T> permits Some, None {
    /// Convert the instance into another instance of the different type using the provided mapping function.
    ///
    /// @param mapper Mapping function
    /// @param <U>    Type of new value
    ///
    /// @return transformed instance
    default <U> Option<U> map(Fn1<U, ? super T> mapper) {
        return fold(Option::empty, t -> present(mapper.apply(t)));
    }

    /// Replace the current instance with the value returned by the provided supplier.
    ///
    /// @param supplier Source of replacement value.
    ///
    /// @return current instance if it is empty or the instance with the replacement value if the current instance is present.
    default <U> Option<U> map(Supplier<U> supplier) {
        return fold(Option::empty, _ -> present(supplier.get()));
    }

    /// Replace the current present instance with another one generated by applying provided mapper to value stored in this instance. An empty instance is
    /// replaced with the empty instance of the new type, matching the type of the provided mapping function.
    ///
    /// @param mapper Mapping function
    /// @param <U>    New type
    ///
    /// @return Instance of the new type
    default <U> Option<U> flatMap(Fn1<Option<U>, ? super T> mapper) {
        return fold(Option::empty, mapper);
    }

    /// Replace the current instance with the instance returned by the provided supplier.
    ///
    /// @param supplier Source of replacement value.
    ///
    /// @return current instance if it is empty or the instance with the replacement value if the current instance is present.
    default <U> Option<U> flatMap(Supplier<Option<U>> supplier) {
        return fold(Option::empty, _ -> supplier.get());
    }

    /// Check the contained value with the provided predicate and transform the instance accordingly.
    /// If the instance is empty, it remains empty. If the instance contains a value, this value
    /// is passed to predicate. If predicate returns <code>true</code> then instance remains
    /// as is. If predicate returns <code>false</code> then empty instance is returned instead.
    ///
    /// @param predicate Predicate to test instance value.
    ///
    /// @return current instance if it is not empty and predicate returns <code>true</code> and empty instance otherwise
    default Option<T> filter(Predicate<? super T> predicate) {
        return fold(Option::empty, v -> predicate.test(v)
                                        ? this
                                        : empty());
    }

    /// Pass internal value to provided consumer in-line. Consumer is invoked only if the current instance is not empty. This is a convenience method that
    /// can be inserted at any point of the fluent call chain. Note that the provided consumer should not change value in any way (for example, if the contained
    /// value is mutable collection/map/array/etc.) and should not throw any kind of exceptions.
    ///
    /// @param consumer Consumer to pass contained value to
    ///
    /// @return this instance for fluent call chaining
    default Option<T> onPresent(Consumer<? super T> consumer) {
        apply(Functions::unitFn, consumer);
        return this;
    }

    /// Execute the provided action if the instance contains a value and do nothing otherwise.
    ///
    /// @param runnable Action to execute when instance is present
    ///
    /// @return this instance for fluent call chaining
    default Option<T> onPresentRun(Runnable runnable) {
        return onPresent(_ -> runnable.run());
    }

    /// Execute action if the instance is empty and do nothing otherwise.
    ///
    /// @param action Action to perform on an empty instance
    ///
    /// @return this instance for fluent call chaining
    default Option<T> onEmpty(Runnable action) {
        apply(action, Functions::unitFn);
        return this;
    }

    /// Execute the provided action if the instance is empty and do nothing otherwise. This is an alias for [#onEmpty(Runnable)].
    ///
    /// @param action Action to execute when instance is empty
    ///
    /// @return this instance for fluent call chaining
    default Option<T> onEmptyRun(Runnable action) {
        return onEmpty(action);
    }

    /// Convenience method which allows performing specific actions for empty and present instances at once.
    ///
    /// @param emptyValConsumer    Action to perform in case of empty instance
    /// @param nonEmptyValConsumer Action to perform on the present instance value
    ///
    /// @return this instance for fluent call chaining
    default Option<T> apply(Runnable emptyValConsumer, Consumer<? super T> nonEmptyValConsumer) {
        fold(() -> {
            emptyValConsumer.run();
            return null;
        }, t2 -> {
            nonEmptyValConsumer.accept(t2);
            return null;
        });
        return this;
    }

    /// Return value stored in current instance if current instance is present. If the current instance is empty, then return the provided replacement value.
    ///
    /// @param replacement Replacement value returned in case if the current instance is empty
    ///
    /// @return either value stored in the current instance or provided replacement value if the current instance is empty
    default T or(T replacement) {
        return fold(() -> replacement, Functions::id);
    }

    /// Return value stored in current instance if current instance is present. If the current instance is empty, then return value returned by the provided
    /// supplier. If the current instance is not empty, then the supplier is not invoked.
    ///
    /// @param supplier Supplier for replacement value returned in case if the current instance is empty
    ///
    /// @return either value stored in the current instance or value returned by provided supplier if current instance is empty
    default T or(Supplier<T> supplier) {
        return fold(supplier, Functions::id);
    }

    /// Return current instance if current instance is present. If the current instance is empty, then return the provided replacement option instance.
    ///
    /// @param replacement Replacement option instance for the case when the current instance is empty
    ///
    /// @return either current instance or provided replacement instance if the current instance is empty
    default Option<T> orElse(Option<T> replacement) {
        return fold(() -> replacement, _ -> this);
    }

    /// Return current instance if current instance is present. If the current instance is empty, then retrieve the replacement Option instance from the given
    /// [Supplier].
    ///
    /// @param supplier Source if replacement option instance for the case when the current instance is empty
    ///
    /// @return either current instance or provided replacement instance if the current instance is empty
    default Option<T> orElse(Supplier<Option<T>> supplier) {
        return fold(supplier, _ -> this);
    }

    /// Check if the current instance is present.
    ///
    /// @return `true` if instance is present and `false` otherwise.
    default boolean isPresent() {
        return fold(() -> false, _ -> true);
    }

    /// Check if the current instance is empty.
    ///
    /// @return `true` if instance is empty and `false` otherwise.
    default boolean isEmpty() {
        return fold(() -> true, _ -> false);
    }

    /// Stream current instance. For an empty instance, an empty stream is created. For the present instance, the stream with a single element is returned. The
    /// element is the value stored in the current instance.
    ///
    /// @return created stream
    default Stream<T> stream() {
        return fold(Stream::empty, Stream::of);
    }

    /// Convert current instance to instance of [Result]. The present instance is converted into a success result. The empty instance is converted
    /// into failure [Result] with provided [Cause].
    ///
    /// @param cause the failure necessary for conversion of an empty instance.
    ///
    /// @return created instance
    default Result<T> toResult(Cause cause) {
        return fold(cause::result, Result::success);
    }

    /// Convert current instance to instance of [Result]. The present instance is converted into a success result. The empty instance is converted
    /// into failure [Result] with provided [Cause]. Same as [#toResult(Cause)].
    ///
    /// @param cause the failure necessary for conversion of the empty instance.
    ///
    /// @return created instance
    default Result<T> await(Cause cause) {
        return toResult(cause);
    }

    /// Convert current instance to instance of [Result]. The present instance is converted into a success result. The empty is replaced with the
    /// instance of [Result] with [CoreError.CoreErrors] as a cause.
    ///
    /// @return created instance
    default Result<T> toResult() {
        return toResult(CoreError.emptyOption());
    }

    /// Convert current instance to instance of [Result]. The present instance is converted into a success result. The empty is replaced with the
    /// instance of [Result] with [CoreError.CoreErrors] as a cause. Same as [#toResult()].
    ///
    /// @return created instance
    default Result<T> await() {
        return toResult();
    }

    /// Convert current instance to instance of [Result]. The present instance is converted into a success result. The empty is replaced with the
    /// instance of [Result] returned by the provided supplier.
    ///
    /// @param supplier the supplier for the result necessary for conversion of an empty instance.
    ///
    /// @return created instance
    default Result<T> toResult(Supplier<Result<T>> supplier) {
        return fold(supplier, Result::success);
    }

    /// Convert current instance to instance of [Result]. The present instance is converted into a success result. The empty is replaced with the
    /// instance of [Result] returned by the provided supplier. Same as [#toResult(Supplier)].
    ///
    /// @param supplier the supplier for the result necessary for conversion of an empty instance.
    ///
    /// @return created instance
    default Result<T> await(Supplier<Result<T>> supplier) {
        return toResult(supplier);
    }

    /// Convert current instance to instance of [Promise]. The present instance is converted into success [Promise]. The empty instance is
    /// converted into failure [Promise] with provided [Cause].
    ///
    /// @param cause the failure necessary for conversion of an empty instance.
    ///
    /// @return created instance
    default Promise<T> async(Cause cause) {
        return fold(cause::promise, Promise::success);
    }

    /// Convert current instance to instance of [Promise]. The present instance is converted into success [Promise]. The empty is replaced
    /// with the instance of [Promise] with [CoreError.CoreErrors] as a cause.
    ///
    /// @return created instance
    default Promise<T> async() {
        return async(CoreError.emptyOption());
    }

    /// Convert current instance to instance of [Promise]. The present instance is converted into success [Promise]. The empty is replaced with the
    /// instance of [Promise] returned by the provided supplier.
    ///
    /// @param supplier the supplier for the result necessary for conversion of an empty instance.
    ///
    /// @return created instance
    default Promise<T> async(Supplier<Promise<T>> supplier) {
        return fold(supplier, Promise::success);
    }

    /// Convert current instance to instance of [Optional]. The present instance is converted into the present instance of [Optional]. The
    /// empty instance is converted into an empty instance of [Optional].
    ///
    /// @return created instance
    default Optional<T> toOptional() {
        return fold(Optional::empty, Optional::of);
    }

    /// Handle both possible states (empty/present) and produce a single result from it.
    ///
    /// @param emptyMapper   function to produce value in case of an empty instance
    /// @param presentMapper function to transform present value into output value
    ///
    /// @return the output of one of the mappers.
    <U> U fold(Supplier<? extends U> emptyMapper, Fn1<? extends U, ? super T> presentMapper);

    //------------------------------------------------------------------------------------------------------------------
    // Instance all() methods - for-comprehension style composition
    //------------------------------------------------------------------------------------------------------------------

    /// Chain a dependent operation with access to this Option's value.
    /// Enables for-comprehension style composition without nested flatMaps.
    /// Returns empty Option if this instance is empty.
    ///
    /// @param fn1 Function that takes the current value and returns an Option
    /// @param <T1> Type of the result from fn1
    ///
    /// @return Mapper1 for further transformation
    default <T1> Mapper1<T1> all(Fn1<Option<T1>, T> fn1) {
        return () -> flatMap(v -> fn1.apply(v).map(Tuple::tuple));
    }

    /// Chain two dependent operations with access to this Option's value.
    /// Returns empty Option if this instance is empty or any function returns empty.
    ///
    /// @param fn1 First function that takes the current value and returns an Option
    /// @param fn2 Second function that takes the current value and returns an Option
    /// @param <T1> Type of the result from fn1
    /// @param <T2> Type of the result from fn2
    ///
    /// @return Mapper2 for further transformation
    default <T1, T2> Mapper2<T1, T2> all(
            Fn1<Option<T1>, T> fn1,
            Fn1<Option<T2>, T> fn2
    ) {
        return () -> flatMap(v ->
                fn1.apply(v).flatMap(v1 ->
                        fn2.apply(v).map(v2 -> Tuple.tuple(v1, v2))));
    }

    /// Chain three dependent operations with access to this Option's value.
    /// Returns empty Option if this instance is empty or any function returns empty.
    ///
    /// @param fn1 First function that takes the current value and returns an Option
    /// @param fn2 Second function that takes the current value and returns an Option
    /// @param fn3 Third function that takes the current value and returns an Option
    /// @param <T1> Type of the result from fn1
    /// @param <T2> Type of the result from fn2
    /// @param <T3> Type of the result from fn3
    ///
    /// @return Mapper3 for further transformation
    default <T1, T2, T3> Mapper3<T1, T2, T3> all(
            Fn1<Option<T1>, T> fn1,
            Fn1<Option<T2>, T> fn2,
            Fn1<Option<T3>, T> fn3
    ) {
        return () -> flatMap(v ->
                fn1.apply(v).flatMap(v1 ->
                        fn2.apply(v).flatMap(v2 ->
                                fn3.apply(v).map(v3 -> Tuple.tuple(v1, v2, v3)))));
    }

    /// Chain four dependent operations with access to this Option's value.
    default <T1, T2, T3, T4> Mapper4<T1, T2, T3, T4> all(
            Fn1<Option<T1>, T> fn1,
            Fn1<Option<T2>, T> fn2,
            Fn1<Option<T3>, T> fn3,
            Fn1<Option<T4>, T> fn4
    ) {
        return () -> flatMap(v ->
                fn1.apply(v).flatMap(v1 ->
                        fn2.apply(v).flatMap(v2 ->
                                fn3.apply(v).flatMap(v3 ->
                                        fn4.apply(v).map(v4 -> Tuple.tuple(v1, v2, v3, v4))))));
    }

    /// Chain five dependent operations with access to this Option's value.
    default <T1, T2, T3, T4, T5> Mapper5<T1, T2, T3, T4, T5> all(
            Fn1<Option<T1>, T> fn1,
            Fn1<Option<T2>, T> fn2,
            Fn1<Option<T3>, T> fn3,
            Fn1<Option<T4>, T> fn4,
            Fn1<Option<T5>, T> fn5
    ) {
        return () -> flatMap(v ->
                fn1.apply(v).flatMap(v1 ->
                        fn2.apply(v).flatMap(v2 ->
                                fn3.apply(v).flatMap(v3 ->
                                        fn4.apply(v).flatMap(v4 ->
                                                fn5.apply(v).map(v5 -> Tuple.tuple(v1, v2, v3, v4, v5)))))));
    }

    /// Chain six dependent operations with access to this Option's value.
    default <T1, T2, T3, T4, T5, T6> Mapper6<T1, T2, T3, T4, T5, T6> all(
            Fn1<Option<T1>, T> fn1,
            Fn1<Option<T2>, T> fn2,
            Fn1<Option<T3>, T> fn3,
            Fn1<Option<T4>, T> fn4,
            Fn1<Option<T5>, T> fn5,
            Fn1<Option<T6>, T> fn6
    ) {
        return () -> flatMap(v ->
                fn1.apply(v).flatMap(v1 ->
                        fn2.apply(v).flatMap(v2 ->
                                fn3.apply(v).flatMap(v3 ->
                                        fn4.apply(v).flatMap(v4 ->
                                                fn5.apply(v).flatMap(v5 ->
                                                        fn6.apply(v).map(v6 -> Tuple.tuple(v1, v2, v3, v4, v5, v6))))))));
    }

    /// Chain seven dependent operations with access to this Option's value.
    default <T1, T2, T3, T4, T5, T6, T7> Mapper7<T1, T2, T3, T4, T5, T6, T7> all(
            Fn1<Option<T1>, T> fn1,
            Fn1<Option<T2>, T> fn2,
            Fn1<Option<T3>, T> fn3,
            Fn1<Option<T4>, T> fn4,
            Fn1<Option<T5>, T> fn5,
            Fn1<Option<T6>, T> fn6,
            Fn1<Option<T7>, T> fn7
    ) {
        return () -> flatMap(v ->
                fn1.apply(v).flatMap(v1 ->
                        fn2.apply(v).flatMap(v2 ->
                                fn3.apply(v).flatMap(v3 ->
                                        fn4.apply(v).flatMap(v4 ->
                                                fn5.apply(v).flatMap(v5 ->
                                                        fn6.apply(v).flatMap(v6 ->
                                                                fn7.apply(v).map(v7 -> Tuple.tuple(v1, v2, v3, v4, v5, v6, v7)))))))));
    }

    /// Chain eight dependent operations with access to this Option's value.
    default <T1, T2, T3, T4, T5, T6, T7, T8> Mapper8<T1, T2, T3, T4, T5, T6, T7, T8> all(
            Fn1<Option<T1>, T> fn1,
            Fn1<Option<T2>, T> fn2,
            Fn1<Option<T3>, T> fn3,
            Fn1<Option<T4>, T> fn4,
            Fn1<Option<T5>, T> fn5,
            Fn1<Option<T6>, T> fn6,
            Fn1<Option<T7>, T> fn7,
            Fn1<Option<T8>, T> fn8
    ) {
        return () -> flatMap(v ->
                fn1.apply(v).flatMap(v1 ->
                        fn2.apply(v).flatMap(v2 ->
                                fn3.apply(v).flatMap(v3 ->
                                        fn4.apply(v).flatMap(v4 ->
                                                fn5.apply(v).flatMap(v5 ->
                                                        fn6.apply(v).flatMap(v6 ->
                                                                fn7.apply(v).flatMap(v7 ->
                                                                        fn8.apply(v).map(v8 -> Tuple.tuple(v1, v2, v3, v4, v5, v6, v7, v8))))))))));
    }

    /// Chain nine dependent operations with access to this Option's value.
    default <T1, T2, T3, T4, T5, T6, T7, T8, T9> Mapper9<T1, T2, T3, T4, T5, T6, T7, T8, T9> all(
            Fn1<Option<T1>, T> fn1,
            Fn1<Option<T2>, T> fn2,
            Fn1<Option<T3>, T> fn3,
            Fn1<Option<T4>, T> fn4,
            Fn1<Option<T5>, T> fn5,
            Fn1<Option<T6>, T> fn6,
            Fn1<Option<T7>, T> fn7,
            Fn1<Option<T8>, T> fn8,
            Fn1<Option<T9>, T> fn9
    ) {
        return () -> flatMap(v ->
                fn1.apply(v).flatMap(v1 ->
                        fn2.apply(v).flatMap(v2 ->
                                fn3.apply(v).flatMap(v3 ->
                                        fn4.apply(v).flatMap(v4 ->
                                                fn5.apply(v).flatMap(v5 ->
                                                        fn6.apply(v).flatMap(v6 ->
                                                                fn7.apply(v).flatMap(v7 ->
                                                                        fn8.apply(v).flatMap(v8 ->
                                                                                fn9.apply(v).map(v9 -> Tuple.tuple(v1, v2, v3, v4, v5, v6, v7, v8, v9)))))))))));
    }

    /// Chain ten dependent operations with access to this Option's value.
    default <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> Mapper10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> all(
            Fn1<Option<T1>, T> fn1, Fn1<Option<T2>, T> fn2, Fn1<Option<T3>, T> fn3,
            Fn1<Option<T4>, T> fn4, Fn1<Option<T5>, T> fn5, Fn1<Option<T6>, T> fn6,
            Fn1<Option<T7>, T> fn7, Fn1<Option<T8>, T> fn8, Fn1<Option<T9>, T> fn9,
            Fn1<Option<T10>, T> fn10
    ) {
        return () -> flatMap(v ->
                fn1.apply(v).flatMap(v1 -> fn2.apply(v).flatMap(v2 -> fn3.apply(v).flatMap(v3 ->
                fn4.apply(v).flatMap(v4 -> fn5.apply(v).flatMap(v5 -> fn6.apply(v).flatMap(v6 ->
                fn7.apply(v).flatMap(v7 -> fn8.apply(v).flatMap(v8 -> fn9.apply(v).flatMap(v9 ->
                fn10.apply(v).map(v10 -> Tuple.tuple(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10))))))))))));
    }

    /// Chain eleven dependent operations with access to this Option's value.
    default <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> Mapper11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> all(
            Fn1<Option<T1>, T> fn1, Fn1<Option<T2>, T> fn2, Fn1<Option<T3>, T> fn3,
            Fn1<Option<T4>, T> fn4, Fn1<Option<T5>, T> fn5, Fn1<Option<T6>, T> fn6,
            Fn1<Option<T7>, T> fn7, Fn1<Option<T8>, T> fn8, Fn1<Option<T9>, T> fn9,
            Fn1<Option<T10>, T> fn10, Fn1<Option<T11>, T> fn11
    ) {
        return () -> flatMap(v ->
                fn1.apply(v).flatMap(v1 -> fn2.apply(v).flatMap(v2 -> fn3.apply(v).flatMap(v3 ->
                fn4.apply(v).flatMap(v4 -> fn5.apply(v).flatMap(v5 -> fn6.apply(v).flatMap(v6 ->
                fn7.apply(v).flatMap(v7 -> fn8.apply(v).flatMap(v8 -> fn9.apply(v).flatMap(v9 ->
                fn10.apply(v).flatMap(v10 -> fn11.apply(v).map(v11 ->
                        Tuple.tuple(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11)))))))))))));
    }

    /// Chain twelve dependent operations with access to this Option's value.
    default <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> Mapper12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> all(
            Fn1<Option<T1>, T> fn1, Fn1<Option<T2>, T> fn2, Fn1<Option<T3>, T> fn3,
            Fn1<Option<T4>, T> fn4, Fn1<Option<T5>, T> fn5, Fn1<Option<T6>, T> fn6,
            Fn1<Option<T7>, T> fn7, Fn1<Option<T8>, T> fn8, Fn1<Option<T9>, T> fn9,
            Fn1<Option<T10>, T> fn10, Fn1<Option<T11>, T> fn11, Fn1<Option<T12>, T> fn12
    ) {
        return () -> flatMap(v ->
                fn1.apply(v).flatMap(v1 -> fn2.apply(v).flatMap(v2 -> fn3.apply(v).flatMap(v3 ->
                fn4.apply(v).flatMap(v4 -> fn5.apply(v).flatMap(v5 -> fn6.apply(v).flatMap(v6 ->
                fn7.apply(v).flatMap(v7 -> fn8.apply(v).flatMap(v8 -> fn9.apply(v).flatMap(v9 ->
                fn10.apply(v).flatMap(v10 -> fn11.apply(v).flatMap(v11 -> fn12.apply(v).map(v12 ->
                        Tuple.tuple(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12))))))))))))));
    }

    /// Chain thirteen dependent operations with access to this Option's value.
    default <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> Mapper13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> all(
            Fn1<Option<T1>, T> fn1, Fn1<Option<T2>, T> fn2, Fn1<Option<T3>, T> fn3,
            Fn1<Option<T4>, T> fn4, Fn1<Option<T5>, T> fn5, Fn1<Option<T6>, T> fn6,
            Fn1<Option<T7>, T> fn7, Fn1<Option<T8>, T> fn8, Fn1<Option<T9>, T> fn9,
            Fn1<Option<T10>, T> fn10, Fn1<Option<T11>, T> fn11, Fn1<Option<T12>, T> fn12,
            Fn1<Option<T13>, T> fn13
    ) {
        return () -> flatMap(v ->
                fn1.apply(v).flatMap(v1 -> fn2.apply(v).flatMap(v2 -> fn3.apply(v).flatMap(v3 ->
                fn4.apply(v).flatMap(v4 -> fn5.apply(v).flatMap(v5 -> fn6.apply(v).flatMap(v6 ->
                fn7.apply(v).flatMap(v7 -> fn8.apply(v).flatMap(v8 -> fn9.apply(v).flatMap(v9 ->
                fn10.apply(v).flatMap(v10 -> fn11.apply(v).flatMap(v11 -> fn12.apply(v).flatMap(v12 ->
                fn13.apply(v).map(v13 ->
                        Tuple.tuple(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13)))))))))))))));
    }

    /// Chain fourteen dependent operations with access to this Option's value.
    default <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> Mapper14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> all(
            Fn1<Option<T1>, T> fn1, Fn1<Option<T2>, T> fn2, Fn1<Option<T3>, T> fn3,
            Fn1<Option<T4>, T> fn4, Fn1<Option<T5>, T> fn5, Fn1<Option<T6>, T> fn6,
            Fn1<Option<T7>, T> fn7, Fn1<Option<T8>, T> fn8, Fn1<Option<T9>, T> fn9,
            Fn1<Option<T10>, T> fn10, Fn1<Option<T11>, T> fn11, Fn1<Option<T12>, T> fn12,
            Fn1<Option<T13>, T> fn13, Fn1<Option<T14>, T> fn14
    ) {
        return () -> flatMap(v ->
                fn1.apply(v).flatMap(v1 -> fn2.apply(v).flatMap(v2 -> fn3.apply(v).flatMap(v3 ->
                fn4.apply(v).flatMap(v4 -> fn5.apply(v).flatMap(v5 -> fn6.apply(v).flatMap(v6 ->
                fn7.apply(v).flatMap(v7 -> fn8.apply(v).flatMap(v8 -> fn9.apply(v).flatMap(v9 ->
                fn10.apply(v).flatMap(v10 -> fn11.apply(v).flatMap(v11 -> fn12.apply(v).flatMap(v12 ->
                fn13.apply(v).flatMap(v13 -> fn14.apply(v).map(v14 ->
                        Tuple.tuple(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14))))))))))))))));
    }

    /// Chain fifteen dependent operations with access to this Option's value.
    default <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> Mapper15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> all(
            Fn1<Option<T1>, T> fn1, Fn1<Option<T2>, T> fn2, Fn1<Option<T3>, T> fn3,
            Fn1<Option<T4>, T> fn4, Fn1<Option<T5>, T> fn5, Fn1<Option<T6>, T> fn6,
            Fn1<Option<T7>, T> fn7, Fn1<Option<T8>, T> fn8, Fn1<Option<T9>, T> fn9,
            Fn1<Option<T10>, T> fn10, Fn1<Option<T11>, T> fn11, Fn1<Option<T12>, T> fn12,
            Fn1<Option<T13>, T> fn13, Fn1<Option<T14>, T> fn14, Fn1<Option<T15>, T> fn15
    ) {
        return () -> flatMap(v ->
                fn1.apply(v).flatMap(v1 -> fn2.apply(v).flatMap(v2 -> fn3.apply(v).flatMap(v3 ->
                fn4.apply(v).flatMap(v4 -> fn5.apply(v).flatMap(v5 -> fn6.apply(v).flatMap(v6 ->
                fn7.apply(v).flatMap(v7 -> fn8.apply(v).flatMap(v8 -> fn9.apply(v).flatMap(v9 ->
                fn10.apply(v).flatMap(v10 -> fn11.apply(v).flatMap(v11 -> fn12.apply(v).flatMap(v12 ->
                fn13.apply(v).flatMap(v13 -> fn14.apply(v).flatMap(v14 -> fn15.apply(v).map(v15 ->
                        Tuple.tuple(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15)))))))))))))))));
    }

    /// Convert nullable value into instance of [Option]. This method converts `null` to the empty instance and any other value into the present
    /// instance.
    ///
    /// @param value Value to convert.
    ///
    /// @return a created instance.
    static <T> Option<T> option(T value) {
        return value == null ? Option.empty() : Option.present(value);
    }

    /// Create an instance of [Option] from [Optional].
    ///
    /// @param optional input optional instance.
    ///
    /// @return a created instance.
    @SuppressWarnings("OptionalUsedAsFieldOrParameterType")
    static <T> Option<T> from(Optional<T> optional) {
        return option(optional.orElse(null));
    }

    /// Create an empty instance.
    ///
    /// @return Created instance
    @SuppressWarnings("unchecked")
    static <U> Option<U> empty() {
        return (Option<U>) NONE;
    }

    /// Create an empty instance.
    ///
    /// @return Created instance
    @SuppressWarnings("unchecked")
    static <U> Option<U> none() {
        return (Option<U>) NONE;
    }

    /// Create a present instance with the passed value.
    ///
    /// @param value Value to be stored in the created instance.
    ///
    /// @return Created instance
    static <U> Option<U> present(U value) {
        return new Some<>(value);
    }

    /// Create a present instance with the passed value.
    ///
    /// @param value Value to be stored in the created instance.
    ///
    /// @return Created instance
    static <U> Option<U> some(U value) {
        return new Some<>(value);
    }

    record Some<T>(T value) implements Option<T> {
        @Override
        public <U> U fold(Supplier<? extends U> emptyMapper, Fn1<? extends U, ? super T> presentMapper) {
            return presentMapper.apply(value);
        }

        @Override
        public String toString() {
            return "Some(" + value + ")";
        }
    }

    record None<T>() implements Option<T> {
        @Override
        public <U> U fold(Supplier<? extends U> emptyMapper, Fn1<? extends U, ? super T> presentMapper) {
            return emptyMapper.get();
        }

        @Override
        public String toString() {
            return "None()";
        }
    }

    @SuppressWarnings({"rawtypes"})
    None NONE = new None();

    /// This method allows "unwrapping" the value stored inside the Option instance. If the value is missing, then [IllegalStateException] is thrown.
    ///
    /// WARNING!!!
    /// This method should be avoided in the production code. Its main intended use case - simplification of the tests. For this reason
    /// the method is marked as [Deprecated]. This generates a warning at compile time.
    ///
    /// @return value stored inside present instance.
    @SuppressWarnings("DeprecatedIsStillUsed")
    @Deprecated
    default T unwrap() {
        return getOrThrow("Option is empty");
    }

    /// This method assumes that some previous code ensures that [Option] we're working with is present
    /// and allows extracting value from monad. If this is not the case, the method throws [ExpectationMismatchError], which
    /// most likely will cause application to crash.
    ///
    /// @param message Error message to include if option is empty
    ///
    /// @return value stored inside present instance
    default T expect(String message) {
        return getOrThrow(message);
    }

    /// Extract the value or throw a custom exception if this Option is empty.
    ///
    /// This method is intended for cases where you need to convert an empty Option into
    /// an exception, typically at API boundaries or in test code.
    ///
    /// @param exceptionFactory factory function that creates an exception from the error message
    /// @param message context message to include in the exception
    ///
    /// @return the value if this Option is present
    /// @throws RuntimeException created by the factory if this Option is empty
    default T getOrThrow(Fn1<RuntimeException, String> exceptionFactory, String message) {
        return fold(() -> { throw exceptionFactory.apply(message); }, Functions::id);
    }

    /// Extract the value or throw an [IllegalStateException] if this Option is empty.
    ///
    /// This method is intended for cases where you are confident the Option is present,
    /// typically in test code or after explicit presence checks.
    ///
    /// @param message context message to include in the exception
    ///
    /// @return the value if this Option is present
    /// @throws IllegalStateException if this Option is empty
    default T getOrThrow(String message) {
        return getOrThrow(IllegalStateException::new, message);
    }

    /// Convenience method for directly invoking a function that may return null and wrapping the result in an Option.
    /// This method provides immediate invocation rather than returning a function factory.
    ///
    /// @param function   The unary function to invoke
    /// @param inputValue The parameter value to pass to the function
    /// @param <R>        The return type of the function
    /// @param <T>        The type of the parameter
    ///
    /// @return An Option that contains the function result or empty if the result is null
    static <R, T> Option<R> lift1(Fn1<R, T> function, T inputValue) {
        return lift(() -> function.apply(inputValue));
    }

    /// Convenience method for directly invoking a binary function that may return null and wrapping the result in an Option.
    /// This method provides immediate invocation rather than returning a function factory.
    ///
    /// @param function     The binary function to invoke
    /// @param inputValue1  The first parameter value to pass to the function
    /// @param inputValue2  The second parameter value to pass to the function
    /// @param <R>          The return type of the function
    /// @param <T1>         The type of the first parameter
    /// @param <T2>         The type of the second parameter
    ///
    /// @return An Option that contains the function result or empty if the result is null
    static <R, T1, T2> Option<R> lift2(Fn2<R, T1, T2> function, T1 inputValue1, T2 inputValue2) {
        return lift(() -> function.apply(inputValue1, inputValue2));
    }

    /// Convenience method for directly invoking a ternary function that may return null and wrapping the result in an Option.
    /// This method provides immediate invocation rather than returning a function factory.
    ///
    /// @param function     The ternary function to invoke
    /// @param inputValue1  The first parameter value to pass to the function
    /// @param inputValue2  The second parameter value to pass to the function
    /// @param inputValue3  The third parameter value to pass to the function
    /// @param <R>          The return type of the function
    /// @param <T1>         The type of the first parameter
    /// @param <T2>         The type of the second parameter
    /// @param <T3>         The type of the third parameter
    ///
    /// @return An Option that contains the function result or empty if the result is null
    static <R, T1, T2, T3> Option<R> lift3(Fn3<R, T1, T2, T3> function, T1 inputValue1, T2 inputValue2, T3 inputValue3) {
        return lift(() -> function.apply(inputValue1, inputValue2, inputValue3));
    }

    /// Convenience method for wrapping functions/methods which may return `null` and accept no parameters.
    ///
    /// @param function function to wrap
    ///
    /// @return value returned by the provided function wrapped into [Option]
    static <R> Option<R> lift(Fn0<R> function) {
        try {
            return option(function.apply());
        } catch (Throwable e) {
            return Option.empty();
        }
    }

    /// Find a first present option among ones passed as parameters.
    ///
    /// @return the first present option or empty option if all input options are empty.
    @SafeVarargs
    static <T> Option<T> any(Option<T>... ops) {
        for (var option : ops) {
            if (option.isPresent()) {
                return option;
            }
        }
        return empty();
    }

    /// Find a first present option among ones passed as parameters. Unlike [#any(Option[])] method, only the first parameter is evaluated eagerly,
    /// others are evaluated lazily and only if previous evaluated instances were empty.
    ///
    /// @return the first present option or empty option if all input options are empty.
    @SafeVarargs
    static <T> Option<T> any(Option<T> op, Supplier<Option<T>>... ops) {
        return op.fold(() -> {
            for (var option : ops) {
                var result = option.get();
                if (result.isPresent()) {
                    return result;
                }
            }
            return op;
        }, _ -> op);
    }

    /// Transform a number of Option values into an Option instance containing a list of values. Result is an empty Option if any value in the input is empty.
    /// Otherwise, the result is a present option with the list of values which were stored inside input Option instances.
    ///
    /// @param values values to transform.
    ///
    /// @return Empty option if the input list contains empty Option instances. Otherwise, returns Option containing a list of values.
    @SafeVarargs
    static <T> Option<List<T>> allOf(Option<T>... values) {
        return allOf(List.of(values));
    }

    /// Transform a list of Option values into an Option instance containing a list of values. Result is an empty Option if any value in the list is empty.
    /// Otherwise, the result is a present option with the list of values which were stored inside input Option instances.
    ///
    /// @param values values to transform.
    ///
    /// @return Empty option if the input list contains empty Option instances. Otherwise, returns Option containing a list of values.
    static <T> Option<List<T>> allOf(List<Option<T>> values) {
        var result = new ArrayList<T>();
        for (var value : values) {
            if (value.isEmpty()) {
                return empty();
            }
            value.onPresent(result::add);
        }
        return present(result);
    }

    /// Transform option into option of tuple with a single value. The result is empty if the input option is empty. Otherwise, the resulting instance contains
    /// a tuple with the input option value.
    ///
    /// @return [Mapper1] prepared for further transformation.
    static <T1> Mapper1<T1> all(Option<T1> op1) {
        return () -> op1.flatMap(v1 -> some(tuple(v1)));
    }

    /// Transform options into option with the tuple of two values. The result is empty if any input option is empty. Otherwise, the resulting instance contains
    /// a tuple with values from input options.
    ///
    /// @return [Mapper2] prepared for further transformation.
    static <T1, T2> Mapper2<T1, T2> all(Option<T1> op1, Option<T2> op2) {
        return () -> op1.flatMap(v1 -> op2.flatMap(v2 -> some(tuple(v1, v2))));
    }

    /// Transform options into option with the tuple of three values. The result is empty if any input option is empty. Otherwise, the resulting instance
    /// contains a tuple with values from input options.
    ///
    /// @return [Mapper3] prepared for further transformation.
    static <T1, T2, T3> Mapper3<T1, T2, T3> all(Option<T1> op1, Option<T2> op2, Option<T3> op3) {
        return () -> op1.flatMap(v1 -> op2.flatMap(v2 -> op3.flatMap(v3 -> some(tuple(v1, v2, v3)))));
    }

    /// Transform options into option with the tuple of four values. The result is empty if any input option is empty. Otherwise, the resulting instance contains
    /// a tuple with values from input options.
    ///
    /// @return [Mapper4] prepared for further transformation.
    static <T1, T2, T3, T4> Mapper4<T1, T2, T3, T4> all(
        Option<T1> op1, Option<T2> op2, Option<T3> op3, Option<T4> op4
    ) {
        return () -> op1.flatMap(
            v1 -> op2.flatMap(
                v2 -> op3.flatMap(
                    v3 -> op4.flatMap(
                        v4 -> some(tuple(v1, v2, v3, v4))))));
    }

    /// Transform options into option with the tuple of five values. The result is empty if any input option is empty. Otherwise, the resulting instance contains
    /// a tuple with values from input options.
    ///
    /// @return [Mapper5] prepared for further transformation.
    static <T1, T2, T3, T4, T5> Mapper5<T1, T2, T3, T4, T5> all(
        Option<T1> op1, Option<T2> op2, Option<T3> op3, Option<T4> op4, Option<T5> op5
    ) {
        return () -> op1.flatMap(
            v1 -> op2.flatMap(
                v2 -> op3.flatMap(
                    v3 -> op4.flatMap(
                        v4 -> op5.flatMap(
                            v5 -> some(tuple(v1, v2, v3, v4, v5)))))));
    }

    /// Transform options into option with the tuple of six values. The result is empty if any input option is empty. Otherwise, the resulting instance contains
    /// a tuple with values from input options.
    ///
    /// @return [Mapper6] prepared for further transformation.
    static <T1, T2, T3, T4, T5, T6> Mapper6<T1, T2, T3, T4, T5, T6> all(
        Option<T1> op1, Option<T2> op2, Option<T3> op3,
        Option<T4> op4, Option<T5> op5, Option<T6> op6
    ) {
        return () -> op1.flatMap(
            v1 -> op2.flatMap(
                v2 -> op3.flatMap(
                    v3 -> op4.flatMap(
                        v4 -> op5.flatMap(
                            v5 -> op6.flatMap(
                                v6 -> some(tuple(v1, v2, v3, v4, v5, v6))))))));
    }

    /// Transform options into option with the tuple of seven values. The result is empty if any input option is empty. Otherwise, the resulting instance
    /// contains a tuple with values from input options.
    ///
    /// @return [Mapper7] prepared for further transformation.
    static <T1, T2, T3, T4, T5, T6, T7> Mapper7<T1, T2, T3, T4, T5, T6, T7> all(
        Option<T1> op1, Option<T2> op2, Option<T3> op3, Option<T4> op4,
        Option<T5> op5, Option<T6> op6, Option<T7> op7
    ) {
        return () -> op1.flatMap(
            v1 -> op2.flatMap(
                v2 -> op3.flatMap(
                    v3 -> op4.flatMap(
                        v4 -> op5.flatMap(
                            v5 -> op6.flatMap(
                                v6 -> op7.flatMap(
                                    v7 -> some(tuple(v1, v2, v3, v4, v5, v6, v7)))))))));
    }

    /// Transform options into option with the tuple of eight values. The result is empty if any input option is empty. Otherwise, the resulting instance
    /// contains a tuple with values from input options.
    ///
    /// @return [Mapper8] prepared for further transformation.
    static <T1, T2, T3, T4, T5, T6, T7, T8> Mapper8<T1, T2, T3, T4, T5, T6, T7, T8> all(
        Option<T1> op1, Option<T2> op2, Option<T3> op3, Option<T4> op4,
        Option<T5> op5, Option<T6> op6, Option<T7> op7, Option<T8> op8
    ) {
        return () -> op1.flatMap(
            v1 -> op2.flatMap(
                v2 -> op3.flatMap(
                    v3 -> op4.flatMap(
                        v4 -> op5.flatMap(
                            v5 -> op6.flatMap(
                                v6 -> op7.flatMap(
                                    v7 -> op8.flatMap(
                                        v8 -> some(tuple(v1, v2, v3, v4, v5, v6, v7, v8))))))))));
    }

    /// Transform options into option with the tuple of nine values. The result is empty if any input option is empty. Otherwise, the resulting instance contains
    /// a tuple with values from input options.
    ///
    /// @return [Mapper9] prepared for further transformation.
    static <T1, T2, T3, T4, T5, T6, T7, T8, T9> Mapper9<T1, T2, T3, T4, T5, T6, T7, T8, T9> all(
        Option<T1> op1, Option<T2> op2, Option<T3> op3, Option<T4> op4, Option<T5> op5,
        Option<T6> op6, Option<T7> op7, Option<T8> op8, Option<T9> op9
    ) {
        return () -> op1.flatMap(
            v1 -> op2.flatMap(
                v2 -> op3.flatMap(
                    v3 -> op4.flatMap(
                        v4 -> op5.flatMap(
                            v5 -> op6.flatMap(
                                v6 -> op7.flatMap(
                                    v7 -> op8.flatMap(
                                        v8 -> op9.flatMap(
                                            v9 -> some(tuple(v1, v2, v3, v4, v5, v6, v7, v8, v9)))))))))));
    }

    static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> Mapper10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> all(
        Option<T1> op1, Option<T2> op2, Option<T3> op3, Option<T4> op4, Option<T5> op5,
        Option<T6> op6, Option<T7> op7, Option<T8> op8, Option<T9> op9, Option<T10> op10
    ) {
        return () -> op1.flatMap(v1 -> op2.flatMap(v2 -> op3.flatMap(v3 -> op4.flatMap(v4 -> op5.flatMap(v5 ->
            op6.flatMap(v6 -> op7.flatMap(v7 -> op8.flatMap(v8 -> op9.flatMap(v9 -> op10.flatMap(v10 ->
                some(tuple(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10))))))))))));
    }

    static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> Mapper11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> all(
        Option<T1> op1, Option<T2> op2, Option<T3> op3, Option<T4> op4, Option<T5> op5,
        Option<T6> op6, Option<T7> op7, Option<T8> op8, Option<T9> op9, Option<T10> op10, Option<T11> op11
    ) {
        return () -> op1.flatMap(v1 -> op2.flatMap(v2 -> op3.flatMap(v3 -> op4.flatMap(v4 -> op5.flatMap(v5 ->
            op6.flatMap(v6 -> op7.flatMap(v7 -> op8.flatMap(v8 -> op9.flatMap(v9 -> op10.flatMap(v10 ->
                op11.flatMap(v11 -> some(tuple(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11)))))))))))));
    }

    static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> Mapper12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> all(
        Option<T1> op1, Option<T2> op2, Option<T3> op3, Option<T4> op4, Option<T5> op5, Option<T6> op6,
        Option<T7> op7, Option<T8> op8, Option<T9> op9, Option<T10> op10, Option<T11> op11, Option<T12> op12
    ) {
        return () -> op1.flatMap(v1 -> op2.flatMap(v2 -> op3.flatMap(v3 -> op4.flatMap(v4 -> op5.flatMap(v5 ->
            op6.flatMap(v6 -> op7.flatMap(v7 -> op8.flatMap(v8 -> op9.flatMap(v9 -> op10.flatMap(v10 ->
                op11.flatMap(v11 -> op12.flatMap(v12 ->
                    some(tuple(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12))))))))))))));
    }

    static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> Mapper13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> all(
        Option<T1> op1, Option<T2> op2, Option<T3> op3, Option<T4> op4, Option<T5> op5, Option<T6> op6,
        Option<T7> op7, Option<T8> op8, Option<T9> op9, Option<T10> op10, Option<T11> op11, Option<T12> op12,
        Option<T13> op13
    ) {
        return () -> op1.flatMap(v1 -> op2.flatMap(v2 -> op3.flatMap(v3 -> op4.flatMap(v4 -> op5.flatMap(v5 ->
            op6.flatMap(v6 -> op7.flatMap(v7 -> op8.flatMap(v8 -> op9.flatMap(v9 -> op10.flatMap(v10 ->
                op11.flatMap(v11 -> op12.flatMap(v12 -> op13.flatMap(v13 ->
                    some(tuple(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13)))))))))))))));
    }

    static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> Mapper14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> all(
        Option<T1> op1, Option<T2> op2, Option<T3> op3, Option<T4> op4, Option<T5> op5, Option<T6> op6,
        Option<T7> op7, Option<T8> op8, Option<T9> op9, Option<T10> op10, Option<T11> op11, Option<T12> op12,
        Option<T13> op13, Option<T14> op14
    ) {
        return () -> op1.flatMap(v1 -> op2.flatMap(v2 -> op3.flatMap(v3 -> op4.flatMap(v4 -> op5.flatMap(v5 ->
            op6.flatMap(v6 -> op7.flatMap(v7 -> op8.flatMap(v8 -> op9.flatMap(v9 -> op10.flatMap(v10 ->
                op11.flatMap(v11 -> op12.flatMap(v12 -> op13.flatMap(v13 -> op14.flatMap(v14 ->
                    some(tuple(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14))))))))))))))));
    }

    static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> Mapper15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> all(
        Option<T1> op1, Option<T2> op2, Option<T3> op3, Option<T4> op4, Option<T5> op5, Option<T6> op6,
        Option<T7> op7, Option<T8> op8, Option<T9> op9, Option<T10> op10, Option<T11> op11, Option<T12> op12,
        Option<T13> op13, Option<T14> op14, Option<T15> op15
    ) {
        return () -> op1.flatMap(v1 -> op2.flatMap(v2 -> op3.flatMap(v3 -> op4.flatMap(v4 -> op5.flatMap(v5 ->
            op6.flatMap(v6 -> op7.flatMap(v7 -> op8.flatMap(v8 -> op9.flatMap(v9 -> op10.flatMap(v10 ->
                op11.flatMap(v11 -> op12.flatMap(v12 -> op13.flatMap(v13 -> op14.flatMap(v14 -> op15.flatMap(v15 ->
                    some(tuple(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15)))))))))))))))));
    }

    /// Helper interface for convenient [Tuple.Tuple1] transformation. In case if you need to return a tuple, it might be more convenient to
    /// return this interface instead. For example, instead of this:
    /// <blockquote><pre>
    ///     return tuple(value, ...);
    /// </pre></blockquote>
    /// return this:
    /// <blockquote><pre>
    ///     return () -> tuple(value, ...);
    /// </pre></blockquote>
    @FunctionalInterface
    interface Mapper1<T1> {
        Option<Tuple.Tuple1<T1>> id();

        default <R> Option<R> map(Fn1<R, T1> mapper) {
            return id().map(tuple -> tuple.map(mapper));
        }

        default <R> Option<R> flatMap(Fn1<Option<R>, T1> mapper) {
            return id().flatMap(tuple -> tuple.map(mapper));
        }
    }

    /// Helper interface for convenient [Tuple.Tuple2] transformation. In case if you need to return a tuple, it might be more convenient to
    /// return this interface instead. For example, instead of this:
    /// <blockquote><pre>
    ///     return tuple(value, ...);
    /// </pre></blockquote>
    /// return this:
    /// <blockquote><pre>
    ///     return () -> tuple(value, ...);
    /// </pre></blockquote>
    @FunctionalInterface
    interface Mapper2<T1, T2> {
        Option<Tuple.Tuple2<T1, T2>> id();

        default <R> Option<R> map(Fn2<R, T1, T2> mapper) {
            return id().map(tuple -> tuple.map(mapper));
        }

        default <R> Option<R> flatMap(Fn2<Option<R>, T1, T2> mapper) {
            return id().flatMap(tuple -> tuple.map(mapper));
        }
    }

    /// Helper interface for convenient [Tuple.Tuple3] transformation. In case if you need to return a tuple, it might be more convenient to
    /// return this interface instead. For example, instead of this:
    /// <blockquote><pre>
    ///     return tuple(value, ...);
    /// </pre></blockquote>
    /// return this:
    /// <blockquote><pre>
    ///     return () -> tuple(value, ...);
    /// </pre></blockquote>
    @FunctionalInterface
    interface Mapper3<T1, T2, T3> {
        Option<Tuple.Tuple3<T1, T2, T3>> id();

        default <R> Option<R> map(Fn3<R, T1, T2, T3> mapper) {
            return id().map(tuple -> tuple.map(mapper));
        }

        default <R> Option<R> flatMap(Fn3<Option<R>, T1, T2, T3> mapper) {
            return id().flatMap(tuple -> tuple.map(mapper));
        }
    }

    /// Helper interface for convenient [Tuple.Tuple4] transformation. In case if you need to return a tuple, it might be more convenient to
    /// return this interface instead. For example, instead of this:
    /// <blockquote><pre>
    ///     return tuple(value, ...);
    /// </pre></blockquote>
    /// return this:
    /// <blockquote><pre>
    ///     return () -> tuple(value, ...);
    /// </pre></blockquote>
    @FunctionalInterface
    interface Mapper4<T1, T2, T3, T4> {
        Option<Tuple.Tuple4<T1, T2, T3, T4>> id();

        default <R> Option<R> map(Fn4<R, T1, T2, T3, T4> mapper) {
            return id().map(tuple -> tuple.map(mapper));
        }

        default <R> Option<R> flatMap(Fn4<Option<R>, T1, T2, T3, T4> mapper) {
            return id().flatMap(tuple -> tuple.map(mapper));
        }
    }

    /// Helper interface for convenient [Tuple.Tuple5] transformation. In case if you need to return a tuple, it might be more convenient to
    /// return this interface instead. For example, instead of this:
    /// <blockquote><pre>
    ///     return tuple(value, ...);
    /// </pre></blockquote>
    /// return this:
    /// <blockquote><pre>
    ///     return () -> tuple(value, ...);
    /// </pre></blockquote>
    @FunctionalInterface
    interface Mapper5<T1, T2, T3, T4, T5> {
        Option<Tuple.Tuple5<T1, T2, T3, T4, T5>> id();

        default <R> Option<R> map(Fn5<R, T1, T2, T3, T4, T5> mapper) {
            return id().map(tuple -> tuple.map(mapper));
        }

        default <R> Option<R> flatMap(Fn5<Option<R>, T1, T2, T3, T4, T5> mapper) {
            return id().flatMap(tuple -> tuple.map(mapper));
        }
    }

    /// Helper interface for convenient [Tuple.Tuple6] transformation. In case if you need to return a tuple, it might be more convenient to
    /// return this interface instead. For example, instead of this:
    /// <blockquote><pre>
    ///     return tuple(value, ...);
    /// </pre></blockquote>
    /// return this:
    /// <blockquote><pre>
    ///     return () -> tuple(value, ...);
    /// </pre></blockquote>
    @FunctionalInterface
    interface Mapper6<T1, T2, T3, T4, T5, T6> {
        Option<Tuple.Tuple6<T1, T2, T3, T4, T5, T6>> id();

        default <R> Option<R> map(Fn6<R, T1, T2, T3, T4, T5, T6> mapper) {
            return id().map(tuple -> tuple.map(mapper));
        }

        default <R> Option<R> flatMap(Fn6<Option<R>, T1, T2, T3, T4, T5, T6> mapper) {
            return id().flatMap(tuple -> tuple.map(mapper));
        }
    }

    /// Helper interface for convenient [Tuple.Tuple7] transformation. In case if you need to return a tuple, it might be more convenient to
    /// return this interface instead. For example, instead of this:
    /// <blockquote><pre>
    ///     return tuple(value, ...);
    /// </pre></blockquote>
    /// return this:
    /// <blockquote><pre>
    ///     return () -> tuple(value, ...);
    /// </pre></blockquote>
    @FunctionalInterface
    interface Mapper7<T1, T2, T3, T4, T5, T6, T7> {
        Option<Tuple.Tuple7<T1, T2, T3, T4, T5, T6, T7>> id();

        default <R> Option<R> map(Fn7<R, T1, T2, T3, T4, T5, T6, T7> mapper) {
            return id().map(tuple -> tuple.map(mapper));
        }

        default <R> Option<R> flatMap(Fn7<Option<R>, T1, T2, T3, T4, T5, T6, T7> mapper) {
            return id().flatMap(tuple -> tuple.map(mapper));
        }
    }

    /// Helper interface for convenient [Tuple.Tuple8] transformation. In case if you need to return a tuple, it might be more convenient to
    /// return this interface instead. For example, instead of this:
    /// <blockquote><pre>
    ///     return tuple(value, ...);
    /// </pre></blockquote>
    /// return this:
    /// <blockquote><pre>
    ///     return () -> tuple(value, ...);
    /// </pre></blockquote>
    @FunctionalInterface
    interface Mapper8<T1, T2, T3, T4, T5, T6, T7, T8> {
        Option<Tuple.Tuple8<T1, T2, T3, T4, T5, T6, T7, T8>> id();

        default <R> Option<R> map(Fn8<R, T1, T2, T3, T4, T5, T6, T7, T8> mapper) {
            return id().map(tuple -> tuple.map(mapper));
        }

        default <R> Option<R> flatMap(Fn8<Option<R>, T1, T2, T3, T4, T5, T6, T7, T8> mapper) {
            return id().flatMap(tuple -> tuple.map(mapper));
        }
    }

    /// Helper interface for convenient [Tuple.Tuple9] transformation. In case if you need to return a tuple, it might be more convenient to
    /// return this interface instead. For example, instead of this:
    /// <blockquote><pre>
    ///     return tuple(value, ...);
    /// </pre></blockquote>
    /// return this:
    /// <blockquote><pre>
    ///     return () -> tuple(value, ...);
    /// </pre></blockquote>
    @FunctionalInterface
    interface Mapper9<T1, T2, T3, T4, T5, T6, T7, T8, T9> {
        Option<Tuple.Tuple9<T1, T2, T3, T4, T5, T6, T7, T8, T9>> id();

        default <R> Option<R> map(Fn9<R, T1, T2, T3, T4, T5, T6, T7, T8, T9> mapper) {
            return id().map(tuple -> tuple.map(mapper));
        }

        default <R> Option<R> flatMap(Fn9<Option<R>, T1, T2, T3, T4, T5, T6, T7, T8, T9> mapper) {
            return id().flatMap(tuple -> tuple.map(mapper));
        }
    }

    interface Mapper10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> {
        Option<Tuple.Tuple10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>> id();

        default <R> Option<R> map(Fn10<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> mapper) {
            return id().map(tuple -> tuple.map(mapper));
        }

        default <R> Option<R> flatMap(Fn10<Option<R>, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> mapper) {
            return id().flatMap(tuple -> tuple.map(mapper));
        }
    }

    interface Mapper11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> {
        Option<Tuple.Tuple11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>> id();

        default <R> Option<R> map(Fn11<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> mapper) {
            return id().map(tuple -> tuple.map(mapper));
        }

        default <R> Option<R> flatMap(Fn11<Option<R>, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> mapper) {
            return id().flatMap(tuple -> tuple.map(mapper));
        }
    }

    interface Mapper12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> {
        Option<Tuple.Tuple12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>> id();

        default <R> Option<R> map(Fn12<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> mapper) {
            return id().map(tuple -> tuple.map(mapper));
        }

        default <R> Option<R> flatMap(Fn12<Option<R>, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> mapper) {
            return id().flatMap(tuple -> tuple.map(mapper));
        }
    }

    interface Mapper13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> {
        Option<Tuple.Tuple13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>> id();

        default <R> Option<R> map(Fn13<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> mapper) {
            return id().map(tuple -> tuple.map(mapper));
        }

        default <R> Option<R> flatMap(Fn13<Option<R>, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> mapper) {
            return id().flatMap(tuple -> tuple.map(mapper));
        }
    }

    interface Mapper14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> {
        Option<Tuple.Tuple14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>> id();

        default <R> Option<R> map(Fn14<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> mapper) {
            return id().map(tuple -> tuple.map(mapper));
        }

        default <R> Option<R> flatMap(Fn14<Option<R>, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> mapper) {
            return id().flatMap(tuple -> tuple.map(mapper));
        }
    }

    interface Mapper15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> {
        Option<Tuple.Tuple15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>> id();

        default <R> Option<R> map(Fn15<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> mapper) {
            return id().map(tuple -> tuple.map(mapper));
        }

        default <R> Option<R> flatMap(Fn15<Option<R>, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> mapper) {
            return id().flatMap(tuple -> tuple.map(mapper));
        }
    }
}
