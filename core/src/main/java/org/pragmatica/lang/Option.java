/*
 *  Copyright (c) 2020-2025 Sergiy Yevtushenko.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package org.pragmatica.lang;

import org.pragmatica.lang.Functions.*;
import org.pragmatica.lang.Option.None;
import org.pragmatica.lang.Option.Some;
import org.pragmatica.lang.io.CoreError;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.function.Consumer;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.stream.Stream;

import static org.pragmatica.lang.Tuple.tuple;

/// Implementation of the basic immutable container for value which may or may not be present.
///
/// @param <T> Type of contained value
@SuppressWarnings("unused")
public sealed interface Option<T> permits Some, None {
    /// Convert the instance into another instance of the different type using the provided mapping function.
    ///
    /// @param mapper Mapping function
    /// @param <U>    Type of new value
    ///
    /// @return transformed instance
    default <U> Option<U> map(Fn1<U, ? super T> mapper) {
        return fold(Option::empty, t -> present(mapper.apply(t)));
    }

    /// Replace the current instance with the value returned by the provided supplier.
    ///
    /// @param supplier Source of replacement value.
    ///
    /// @return current instance if it is empty or the instance with the replacement value if the current instance is present.
    default <U> Option<U> map(Supplier<U> supplier) {
        return fold(Option::empty, _ -> present(supplier.get()));
    }

    /// Replace the current present instance with another one generated by applying provided mapper to value stored in this instance. An empty instance is
    /// replaced with the empty instance of the new type, matching the type of the provided mapping function.
    ///
    /// @param mapper Mapping function
    /// @param <U>    New type
    ///
    /// @return Instance of the new type
    default <U> Option<U> flatMap(Fn1<Option<U>, ? super T> mapper) {
        return fold(Option::empty, mapper);
    }

    /// Replace the current instance with the instance returned by the provided supplier.
    ///
    /// @param supplier Source of replacement value.
    ///
    /// @return current instance if it is empty or the instance with the replacement value if the current instance is present.
    default <U> Option<U> flatMap(Supplier<Option<U>> supplier) {
        return fold(Option::empty, _ -> supplier.get());
    }

    /// Check the contained value with the provided predicate and transform the instance accordingly.
    /// If the instance is empty, it remains empty. If the instance contains a value, this value
    /// is passed to predicate. If predicate returns <code>true</code> then instance remains
    /// as is. If predicate returns <code>false</code> then empty instance is returned instead.
    ///
    /// @param predicate Predicate to test instance value.
    ///
    /// @return current instance if it is not empty and predicate returns <code>true</code> and empty instance otherwise
    default Option<T> filter(Predicate<? super T> predicate) {
        return fold(Option::empty, v -> predicate.test(v)
                                        ? this
                                        : empty());
    }

    /// Pass internal value to provided consumer in-line. Consumer is invoked only if the current instance is not empty. This is a convenience method that
    /// can be inserted at any point of the fluent call chain. Note that the provided consumer should not change value in any way (for example, if the contained
    /// value is mutable collection/map/array/etc.) and should not throw any kind of exceptions.
    ///
    /// @param consumer Consumer to pass contained value to
    ///
    /// @return this instance for fluent call chaining
    default Option<T> onPresent(Consumer<? super T> consumer) {
        apply(Functions::unitFn, consumer);
        return this;
    }

    default Option<T> onPresentRun(Runnable runnable) {
        return onPresent(_ -> runnable.run());
    }

    /// Execute action if the instance is empty and do nothing otherwise.
    ///
    /// @param action Action to perform on an empty instance
    ///
    /// @return this instance for fluent call chaining
    default Option<T> onEmpty(Runnable action) {
        apply(action, Functions::unitFn);
        return this;
    }

    default Option<T> onEmptyRun(Runnable action) {
        return onEmpty(action);
    }

    /// Convenience method which allows performing specific actions for empty and present instances at once.
    ///
    /// @param emptyValConsumer    Action to perform in case of empty instance
    /// @param nonEmptyValConsumer Action to perform on the present instance value
    ///
    /// @return this instance for fluent call chaining
    default Option<T> apply(Runnable emptyValConsumer, Consumer<? super T> nonEmptyValConsumer) {
        fold(() -> {
            emptyValConsumer.run();
            return null;
        }, t2 -> {
            nonEmptyValConsumer.accept(t2);
            return null;
        });
        return this;
    }

    /// Return value stored in current instance if current instance is present. If the current instance is empty, then return the provided replacement value.
    ///
    /// @param replacement Replacement value returned in case if the current instance is empty
    ///
    /// @return either value stored in the current instance or provided replacement value if the current instance is empty
    default T or(T replacement) {
        return fold(() -> replacement, Functions::id);
    }

    /// Return value stored in current instance if current instance is present. If the current instance is empty, then return value returned by the provided
    /// supplier. If the current instance is not empty, then the supplier is not invoked.
    ///
    /// @param supplier Supplier for replacement value returned in case if the current instance is empty
    ///
    /// @return either value stored in the current instance or value returned by provided supplier if current instance is empty
    default T or(Supplier<T> supplier) {
        return fold(supplier, Functions::id);
    }

    /// Return current instance if current instance is present. If the current instance is empty, then return the provided replacement option instance.
    ///
    /// @param replacement Replacement option instance for the case when the current instance is empty
    ///
    /// @return either current instance or provided replacement instance if the current instance is empty
    default Option<T> orElse(Option<T> replacement) {
        return fold(() -> replacement, _ -> this);
    }

    /// Return current instance if current instance is present. If the current instance is empty, then retrieve the replacement Option instance from the given
    /// [Supplier].
    ///
    /// @param supplier Source if replacement option instance for the case when the current instance is empty
    ///
    /// @return either current instance or provided replacement instance if the current instance is empty
    default Option<T> orElse(Supplier<Option<T>> supplier) {
        return fold(supplier, _ -> this);
    }

    /// Check if the current instance is present.
    ///
    /// @return `true` if instance is present and `false` otherwise.
    default boolean isPresent() {
        return fold(() -> false, _ -> true);
    }

    /// Check if the current instance is empty.
    ///
    /// @return `true` if instance is empty and `false` otherwise.
    default boolean isEmpty() {
        return fold(() -> true, _ -> false);
    }

    /// Stream current instance. For an empty instance, an empty stream is created. For the present instance, the stream with a single element is returned. The
    /// element is the value stored in the current instance.
    ///
    /// @return created stream
    default Stream<T> stream() {
        return fold(Stream::empty, Stream::of);
    }

    /// Convert current instance to instance of [Result]. The present instance is converted into a success result. The empty instance is converted
    /// into failure [Result] with provided [Cause].
    ///
    /// @param cause the failure necessary for conversion of an empty instance.
    ///
    /// @return created instance
    default Result<T> toResult(Cause cause) {
        return fold(cause::result, Result::success);
    }

    /// Convert current instance to instance of [Result]. The present instance is converted into a success result. The empty instance is converted
    /// into failure [Result] with provided [Cause]. Same as [#toResult(Cause)].
    ///
    /// @param cause the failure necessary for conversion of the empty instance.
    ///
    /// @return created instance
    default Result<T> await(Cause cause) {
        return toResult(cause);
    }

    /// Convert current instance to instance of [Result]. The present instance is converted into a success result. The empty is replaced with the
    /// instance of [Result] with [CoreError.CoreErrors] as a cause.
    ///
    /// @return created instance
    default Result<T> toResult() {
        return toResult(CoreError.emptyOption());
    }

    /// Convert current instance to instance of [Result]. The present instance is converted into a success result. The empty is replaced with the
    /// instance of [Result] with [CoreError.CoreErrors] as a cause. Same as [#toResult()].
    ///
    /// @return created instance
    default Result<T> await() {
        return toResult();
    }

    /// Convert current instance to instance of [Result]. The present instance is converted into a success result. The empty is replaced with the
    /// instance of [Result] returned by the provided supplier.
    ///
    /// @param supplier the supplier for the result necessary for conversion of an empty instance.
    ///
    /// @return created instance
    default Result<T> toResult(Supplier<Result<T>> supplier) {
        return fold(supplier, Result::success);
    }

    /// Convert current instance to instance of [Result]. The present instance is converted into a success result. The empty is replaced with the
    /// instance of [Result] returned by the provided supplier. Same as [#toResult(Supplier)].
    ///
    /// @param supplier the supplier for the result necessary for conversion of an empty instance.
    ///
    /// @return created instance
    default Result<T> await(Supplier<Result<T>> supplier) {
        return toResult(supplier);
    }

    /// Convert current instance to instance of [Promise]. The present instance is converted into success [Promise]. The empty instance is
    /// converted into failure [Promise] with provided [Cause].
    ///
    /// @param cause the failure necessary for conversion of an empty instance.
    ///
    /// @return created instance
    default Promise<T> async(Cause cause) {
        return fold(cause::promise, Promise::success);
    }

    /// Convert current instance to instance of [Promise]. The present instance is converted into success [Promise]. The empty is replaced
    /// with the instance of [Promise] with [CoreError.CoreErrors] as a cause.
    ///
    /// @return created instance
    default Promise<T> async() {
        return async(CoreError.emptyOption());
    }

    /// Convert current instance to instance of [Promise]. The present instance is converted into success [Promise]. The empty is replaced with the
    /// instance of [Promise] returned by the provided supplier.
    ///
    /// @param supplier the supplier for the result necessary for conversion of an empty instance.
    ///
    /// @return created instance
    default Promise<T> async(Supplier<Promise<T>> supplier) {
        return fold(supplier, Promise::success);
    }

    /// Convert current instance to instance of [Optional]. The present instance is converted into the present instance of [Optional]. The
    /// empty instance is converted into an empty instance of [Optional].
    ///
    /// @return created instance
    default Optional<T> toOptional() {
        return fold(Optional::empty, Optional::of);
    }

    /// Handle both possible states (empty/present) and produce a single result from it.
    ///
    /// @param emptyMapper   function to produce value in case of an empty instance
    /// @param presentMapper function to transform present value into output value
    ///
    /// @return the output of one of the mappers.
    <U> U fold(Supplier<? extends U> emptyMapper, Fn1<? extends U, ? super T> presentMapper);

    /// Convert nullable value into instance of [Option]. This method converts `null` to the empty instance and any other value into the present
    /// instance.
    ///
    /// @param value Value to convert.
    ///
    /// @return a created instance.
    static <T> Option<T> option(T value) {
        return value == null ? Option.empty() : Option.present(value);
    }

    /// Create an instance of [Option] from [Optional].
    ///
    /// @param optional input optional instance.
    ///
    /// @return a created instance.
    @SuppressWarnings("OptionalUsedAsFieldOrParameterType")
    static <T> Option<T> from(Optional<T> optional) {
        return option(optional.orElse(null));
    }

    /// Create an empty instance.
    ///
    /// @return Created instance
    @SuppressWarnings("unchecked")
    static <U> Option<U> empty() {
        return (Option<U>) NONE;
    }

    /// Create an empty instance.
    ///
    /// @return Created instance
    @SuppressWarnings("unchecked")
    static <U> Option<U> none() {
        return (Option<U>) NONE;
    }

    /// Create a present instance with the passed value.
    ///
    /// @param value Value to be stored in the created instance.
    ///
    /// @return Created instance
    static <U> Option<U> present(U value) {
        return new Some<>(value);
    }

    /// Create a present instance with the passed value.
    ///
    /// @param value Value to be stored in the created instance.
    ///
    /// @return Created instance
    static <U> Option<U> some(U value) {
        return new Some<>(value);
    }

    record Some<T>(T value) implements Option<T> {
        @Override
        public <U> U fold(Supplier<? extends U> emptyMapper, Fn1<? extends U, ? super T> presentMapper) {
            return presentMapper.apply(value);
        }

        @Override
        public String toString() {
            return "Some(" + value + ")";
        }
    }

    record None<T>() implements Option<T> {
        @Override
        public <U> U fold(Supplier<? extends U> emptyMapper, Fn1<? extends U, ? super T> presentMapper) {
            return emptyMapper.get();
        }

        @Override
        public String toString() {
            return "None()";
        }
    }

    @SuppressWarnings({"rawtypes"})
    None NONE = new None();

    /// This method allows "unwrapping" the value stored inside the Option instance. If the value is missing, then [IllegalStateException] is thrown.
    ///
    /// WARNING!!!
    /// This method should be avoided in the production code. Its main intended use case - simplification of the tests. For this reason
    /// the method is marked as [Deprecated]. This generates a warning at compile time.
    ///
    /// @return value stored inside present instance.
    @SuppressWarnings("DeprecatedIsStillUsed")
    @Deprecated
    default T unwrap() {
        return fold(() -> {throw new IllegalStateException("Option is empty!!!");}, Functions::id);
    }

    /// This method assumes that some previous code ensures that [Option] we're working with is not empty
    /// and allows extracting value from monad. If this is not the case, the method throws [Error], which
    /// most likely will cause application to crash.
    default T expect(String message) {
        return fold(() -> {throw new ExpectationMismatchError("Unexpected empty Option: " + message);}, Functions::id);
    }

    /// Convenience method for wrapping functions/methods which may return `null`
    ///
    /// @param function function to wrap
    /// @param inputValue inputValue to pass to function
    ///
    /// @return inputValue returned by the provided function wrapped into [Option]
    /// Convenience method for directly invoking a function that may return null and wrapping the result in an Option.
    /// This method provides immediate invocation rather than returning a function factory.
    ///
    /// @param function   The unary function to invoke
    /// @param inputValue The parameter value to pass to the function
    /// @param <R>        The return type of the function
    /// @param <T>        The type of the parameter
    ///
    /// @return An Option that contains the function result or empty if the result is null
    static <R, T> Option<R> lift1(Fn1<R, T> function, T inputValue) {
        return lift(() -> function.apply(inputValue));
    }

    /// Convenience method for directly invoking a binary function that may return null and wrapping the result in an Option.
    /// This method provides immediate invocation rather than returning a function factory.
    ///
    /// @param function     The binary function to invoke
    /// @param inputValue1  The first parameter value to pass to the function
    /// @param inputValue2  The second parameter value to pass to the function
    /// @param <R>          The return type of the function
    /// @param <T1>         The type of the first parameter
    /// @param <T2>         The type of the second parameter
    ///
    /// @return An Option that contains the function result or empty if the result is null
    static <R, T1, T2> Option<R> lift2(Fn2<R, T1, T2> function, T1 inputValue1, T2 inputValue2) {
        return lift(() -> function.apply(inputValue1, inputValue2));
    }

    /// Convenience method for directly invoking a ternary function that may return null and wrapping the result in an Option.
    /// This method provides immediate invocation rather than returning a function factory.
    ///
    /// @param function     The ternary function to invoke
    /// @param inputValue1  The first parameter value to pass to the function
    /// @param inputValue2  The second parameter value to pass to the function
    /// @param inputValue3  The third parameter value to pass to the function
    /// @param <R>          The return type of the function
    /// @param <T1>         The type of the first parameter
    /// @param <T2>         The type of the second parameter
    /// @param <T3>         The type of the third parameter
    ///
    /// @return An Option that contains the function result or empty if the result is null
    static <R, T1, T2, T3> Option<R> lift3(Fn3<R, T1, T2, T3> function, T1 inputValue1, T2 inputValue2, T3 inputValue3) {
        return lift(() -> function.apply(inputValue1, inputValue2, inputValue3));
    }

    /// Convenience method for wrapping functions/methods which may return `null` and accept no parameters.
    ///
    /// @param function function to wrap
    ///
    /// @return value returned by the provided function wrapped into [Option]
    static <R> Option<R> lift(Fn0<R> function) {
        try {
            return option(function.apply());
        } catch (Throwable e) {
            return Option.empty();
        }
    }

    /// Find a first present option among ones passed as parameters.
    ///
    /// @return the first present option or empty option if all input options are empty.
    @SafeVarargs
    static <T> Option<T> any(Option<T>... ops) {
        for (var option : ops) {
            if (option.isPresent()) {
                return option;
            }
        }
        return empty();
    }

    /// Find a first present option among ones passed as parameters. Unlike [#any(Option[])] method, only the first parameter is evaluated eagerly,
    /// others are evaluated lazily and only if previous evaluated instances were empty.
    ///
    /// @return the first present option or empty option if all input options are empty.
    @SafeVarargs
    static <T> Option<T> any(Option<T> op, Supplier<Option<T>>... ops) {
        return op.fold(() -> {
            for (var option : ops) {
                var result = option.get();
                if (result.isPresent()) {
                    return result;
                }
            }
            return op;
        }, _ -> op);
    }

    /// Transform a number of Option values into an Option instance containing a list of values. Result is an empty Option if any value in the input is empty.
    /// Otherwise, the result is a present option with the list of values which were stored inside input Option instances.
    ///
    /// @param values values to transform.
    ///
    /// @return Empty option if the input list contains empty Option instances. Otherwise, returns Option containing a list of values.
    @SafeVarargs
    static <T> Option<List<T>> allOf(Option<T>... values) {
        return allOf(List.of(values));
    }

    /// Transform a list of Option values into an Option instance containing a list of values. Result is an empty Option if any value in the list is empty.
    /// Otherwise, the result is a present option with the list of values which were stored inside input Option instances.
    ///
    /// @param values values to transform.
    ///
    /// @return Empty option if the input list contains empty Option instances. Otherwise, returns Option containing a list of values.
    static <T> Option<List<T>> allOf(List<Option<T>> values) {
        var result = new ArrayList<T>();
        for (var value : values) {
            if (value.isEmpty()) {
                return empty();
            }
            value.onPresent(result::add);
        }
        return present(result);
    }

    /// Transform option into option of tuple with a single value. The result is empty if the input option is empty. Otherwise, the resulting instance contains
    /// a tuple with the input option value.
    ///
    /// @return [Mapper1] prepared for further transformation.
    static <T1> Mapper1<T1> all(Option<T1> op1) {
        return () -> op1.flatMap(v1 -> some(tuple(v1)));
    }

    /// Transform options into option with the tuple of two values. The result is empty if any input option is empty. Otherwise, the resulting instance contains
    /// a tuple with values from input options.
    ///
    /// @return [Mapper2] prepared for further transformation.
    static <T1, T2> Mapper2<T1, T2> all(Option<T1> op1, Option<T2> op2) {
        return () -> op1.flatMap(v1 -> op2.flatMap(v2 -> some(tuple(v1, v2))));
    }

    /// Transform options into option with the tuple of three values. The result is empty if any input option is empty. Otherwise, the resulting instance
    /// contains a tuple with values from input options.
    ///
    /// @return [Mapper3] prepared for further transformation.
    static <T1, T2, T3> Mapper3<T1, T2, T3> all(Option<T1> op1, Option<T2> op2, Option<T3> op3) {
        return () -> op1.flatMap(v1 -> op2.flatMap(v2 -> op3.flatMap(v3 -> some(tuple(v1, v2, v3)))));
    }

    /// Transform options into option with the tuple of four values. The result is empty if any input option is empty. Otherwise, the resulting instance contains
    /// a tuple with values from input options.
    ///
    /// @return [Mapper4] prepared for further transformation.
    static <T1, T2, T3, T4> Mapper4<T1, T2, T3, T4> all(
        Option<T1> op1, Option<T2> op2, Option<T3> op3, Option<T4> op4
    ) {
        return () -> op1.flatMap(
            v1 -> op2.flatMap(
                v2 -> op3.flatMap(
                    v3 -> op4.flatMap(
                        v4 -> some(tuple(v1, v2, v3, v4))))));
    }

    /// Transform options into option with the tuple of five values. The result is empty if any input option is empty. Otherwise, the resulting instance contains
    /// a tuple with values from input options.
    ///
    /// @return [Mapper5] prepared for further transformation.
    static <T1, T2, T3, T4, T5> Mapper5<T1, T2, T3, T4, T5> all(
        Option<T1> op1, Option<T2> op2, Option<T3> op3, Option<T4> op4, Option<T5> op5
    ) {
        return () -> op1.flatMap(
            v1 -> op2.flatMap(
                v2 -> op3.flatMap(
                    v3 -> op4.flatMap(
                        v4 -> op5.flatMap(
                            v5 -> some(tuple(v1, v2, v3, v4, v5)))))));
    }

    /// Transform options into option with the tuple of six values. The result is empty if any input option is empty. Otherwise, the resulting instance contains
    /// a tuple with values from input options.
    ///
    /// @return [Mapper6] prepared for further transformation.
    static <T1, T2, T3, T4, T5, T6> Mapper6<T1, T2, T3, T4, T5, T6> all(
        Option<T1> op1, Option<T2> op2, Option<T3> op3,
        Option<T4> op4, Option<T5> op5, Option<T6> op6
    ) {
        return () -> op1.flatMap(
            v1 -> op2.flatMap(
                v2 -> op3.flatMap(
                    v3 -> op4.flatMap(
                        v4 -> op5.flatMap(
                            v5 -> op6.flatMap(
                                v6 -> some(tuple(v1, v2, v3, v4, v5, v6))))))));
    }

    /// Transform options into option with the tuple of seven values. The result is empty if any input option is empty. Otherwise, the resulting instance
    /// contains a tuple with values from input options.
    ///
    /// @return [Mapper7] prepared for further transformation.
    static <T1, T2, T3, T4, T5, T6, T7> Mapper7<T1, T2, T3, T4, T5, T6, T7> all(
        Option<T1> op1, Option<T2> op2, Option<T3> op3, Option<T4> op4,
        Option<T5> op5, Option<T6> op6, Option<T7> op7
    ) {
        return () -> op1.flatMap(
            v1 -> op2.flatMap(
                v2 -> op3.flatMap(
                    v3 -> op4.flatMap(
                        v4 -> op5.flatMap(
                            v5 -> op6.flatMap(
                                v6 -> op7.flatMap(
                                    v7 -> some(tuple(v1, v2, v3, v4, v5, v6, v7)))))))));
    }

    /// Transform options into option with the tuple of eight values. The result is empty if any input option is empty. Otherwise, the resulting instance
    /// contains a tuple with values from input options.
    ///
    /// @return [Mapper8] prepared for further transformation.
    static <T1, T2, T3, T4, T5, T6, T7, T8> Mapper8<T1, T2, T3, T4, T5, T6, T7, T8> all(
        Option<T1> op1, Option<T2> op2, Option<T3> op3, Option<T4> op4,
        Option<T5> op5, Option<T6> op6, Option<T7> op7, Option<T8> op8
    ) {
        return () -> op1.flatMap(
            v1 -> op2.flatMap(
                v2 -> op3.flatMap(
                    v3 -> op4.flatMap(
                        v4 -> op5.flatMap(
                            v5 -> op6.flatMap(
                                v6 -> op7.flatMap(
                                    v7 -> op8.flatMap(
                                        v8 -> some(tuple(v1, v2, v3, v4, v5, v6, v7, v8))))))))));
    }

    /// Transform options into option with the tuple of nine values. The result is empty if any input option is empty. Otherwise, the resulting instance contains
    /// a tuple with values from input options.
    ///
    /// @return [Mapper9] prepared for further transformation.
    static <T1, T2, T3, T4, T5, T6, T7, T8, T9> Mapper9<T1, T2, T3, T4, T5, T6, T7, T8, T9> all(
        Option<T1> op1, Option<T2> op2, Option<T3> op3, Option<T4> op4, Option<T5> op5,
        Option<T6> op6, Option<T7> op7, Option<T8> op8, Option<T9> op9
    ) {
        return () -> op1.flatMap(
            v1 -> op2.flatMap(
                v2 -> op3.flatMap(
                    v3 -> op4.flatMap(
                        v4 -> op5.flatMap(
                            v5 -> op6.flatMap(
                                v6 -> op7.flatMap(
                                    v7 -> op8.flatMap(
                                        v8 -> op9.flatMap(
                                            v9 -> some(tuple(v1, v2, v3, v4, v5, v6, v7, v8, v9)))))))))));
    }

    /// Helper interface for convenient [Tuple.Tuple1] transformation. In case if you need to return a tuple, it might be more convenient to
    /// return this interface instead. For example, instead of this:
    /// <blockquote><pre>
    ///     return tuple(value, ...);
    /// </pre></blockquote>
    /// return this:
    /// <blockquote><pre>
    ///     return () -> tuple(value, ...);
    /// </pre></blockquote>
    @FunctionalInterface
    interface Mapper1<T1> {
        Option<Tuple.Tuple1<T1>> id();

        default <R> Option<R> map(Fn1<R, T1> mapper) {
            return id().map(tuple -> tuple.map(mapper));
        }

        default <R> Option<R> flatMap(Fn1<Option<R>, T1> mapper) {
            return id().flatMap(tuple -> tuple.map(mapper));
        }
    }

    /// Helper interface for convenient [Tuple.Tuple2] transformation. In case if you need to return a tuple, it might be more convenient to
    /// return this interface instead. For example, instead of this:
    /// <blockquote><pre>
    ///     return tuple(value, ...);
    /// </pre></blockquote>
    /// return this:
    /// <blockquote><pre>
    ///     return () -> tuple(value, ...);
    /// </pre></blockquote>
    @FunctionalInterface
    interface Mapper2<T1, T2> {
        Option<Tuple.Tuple2<T1, T2>> id();

        default <R> Option<R> map(Fn2<R, T1, T2> mapper) {
            return id().map(tuple -> tuple.map(mapper));
        }

        default <R> Option<R> flatMap(Fn2<Option<R>, T1, T2> mapper) {
            return id().flatMap(tuple -> tuple.map(mapper));
        }
    }

    /// Helper interface for convenient [Tuple.Tuple3] transformation. In case if you need to return a tuple, it might be more convenient to
    /// return this interface instead. For example, instead of this:
    /// <blockquote><pre>
    ///     return tuple(value, ...);
    /// </pre></blockquote>
    /// return this:
    /// <blockquote><pre>
    ///     return () -> tuple(value, ...);
    /// </pre></blockquote>
    @FunctionalInterface
    interface Mapper3<T1, T2, T3> {
        Option<Tuple.Tuple3<T1, T2, T3>> id();

        default <R> Option<R> map(Fn3<R, T1, T2, T3> mapper) {
            return id().map(tuple -> tuple.map(mapper));
        }

        default <R> Option<R> flatMap(Fn3<Option<R>, T1, T2, T3> mapper) {
            return id().flatMap(tuple -> tuple.map(mapper));
        }
    }

    /// Helper interface for convenient [Tuple.Tuple4] transformation. In case if you need to return a tuple, it might be more convenient to
    /// return this interface instead. For example, instead of this:
    /// <blockquote><pre>
    ///     return tuple(value, ...);
    /// </pre></blockquote>
    /// return this:
    /// <blockquote><pre>
    ///     return () -> tuple(value, ...);
    /// </pre></blockquote>
    @FunctionalInterface
    interface Mapper4<T1, T2, T3, T4> {
        Option<Tuple.Tuple4<T1, T2, T3, T4>> id();

        default <R> Option<R> map(Fn4<R, T1, T2, T3, T4> mapper) {
            return id().map(tuple -> tuple.map(mapper));
        }

        default <R> Option<R> flatMap(Fn4<Option<R>, T1, T2, T3, T4> mapper) {
            return id().flatMap(tuple -> tuple.map(mapper));
        }
    }

    /// Helper interface for convenient [Tuple.Tuple5] transformation. In case if you need to return a tuple, it might be more convenient to
    /// return this interface instead. For example, instead of this:
    /// <blockquote><pre>
    ///     return tuple(value, ...);
    /// </pre></blockquote>
    /// return this:
    /// <blockquote><pre>
    ///     return () -> tuple(value, ...);
    /// </pre></blockquote>
    @FunctionalInterface
    interface Mapper5<T1, T2, T3, T4, T5> {
        Option<Tuple.Tuple5<T1, T2, T3, T4, T5>> id();

        default <R> Option<R> map(Fn5<R, T1, T2, T3, T4, T5> mapper) {
            return id().map(tuple -> tuple.map(mapper));
        }

        default <R> Option<R> flatMap(Fn5<Option<R>, T1, T2, T3, T4, T5> mapper) {
            return id().flatMap(tuple -> tuple.map(mapper));
        }
    }

    /// Helper interface for convenient [Tuple.Tuple6] transformation. In case if you need to return a tuple, it might be more convenient to
    /// return this interface instead. For example, instead of this:
    /// <blockquote><pre>
    ///     return tuple(value, ...);
    /// </pre></blockquote>
    /// return this:
    /// <blockquote><pre>
    ///     return () -> tuple(value, ...);
    /// </pre></blockquote>
    @FunctionalInterface
    interface Mapper6<T1, T2, T3, T4, T5, T6> {
        Option<Tuple.Tuple6<T1, T2, T3, T4, T5, T6>> id();

        default <R> Option<R> map(Fn6<R, T1, T2, T3, T4, T5, T6> mapper) {
            return id().map(tuple -> tuple.map(mapper));
        }

        default <R> Option<R> flatMap(Fn6<Option<R>, T1, T2, T3, T4, T5, T6> mapper) {
            return id().flatMap(tuple -> tuple.map(mapper));
        }
    }

    /// Helper interface for convenient [Tuple.Tuple7] transformation. In case if you need to return a tuple, it might be more convenient to
    /// return this interface instead. For example, instead of this:
    /// <blockquote><pre>
    ///     return tuple(value, ...);
    /// </pre></blockquote>
    /// return this:
    /// <blockquote><pre>
    ///     return () -> tuple(value, ...);
    /// </pre></blockquote>
    @FunctionalInterface
    interface Mapper7<T1, T2, T3, T4, T5, T6, T7> {
        Option<Tuple.Tuple7<T1, T2, T3, T4, T5, T6, T7>> id();

        default <R> Option<R> map(Fn7<R, T1, T2, T3, T4, T5, T6, T7> mapper) {
            return id().map(tuple -> tuple.map(mapper));
        }

        default <R> Option<R> flatMap(Fn7<Option<R>, T1, T2, T3, T4, T5, T6, T7> mapper) {
            return id().flatMap(tuple -> tuple.map(mapper));
        }
    }

    /// Helper interface for convenient [Tuple.Tuple8] transformation. In case if you need to return a tuple, it might be more convenient to
    /// return this interface instead. For example, instead of this:
    /// <blockquote><pre>
    ///     return tuple(value, ...);
    /// </pre></blockquote>
    /// return this:
    /// <blockquote><pre>
    ///     return () -> tuple(value, ...);
    /// </pre></blockquote>
    @FunctionalInterface
    interface Mapper8<T1, T2, T3, T4, T5, T6, T7, T8> {
        Option<Tuple.Tuple8<T1, T2, T3, T4, T5, T6, T7, T8>> id();

        default <R> Option<R> map(Fn8<R, T1, T2, T3, T4, T5, T6, T7, T8> mapper) {
            return id().map(tuple -> tuple.map(mapper));
        }

        default <R> Option<R> flatMap(Fn8<Option<R>, T1, T2, T3, T4, T5, T6, T7, T8> mapper) {
            return id().flatMap(tuple -> tuple.map(mapper));
        }
    }

    /// Helper interface for convenient [Tuple.Tuple9] transformation. In case if you need to return a tuple, it might be more convenient to
    /// return this interface instead. For example, instead of this:
    /// <blockquote><pre>
    ///     return tuple(value, ...);
    /// </pre></blockquote>
    /// return this:
    /// <blockquote><pre>
    ///     return () -> tuple(value, ...);
    /// </pre></blockquote>
    @FunctionalInterface
    interface Mapper9<T1, T2, T3, T4, T5, T6, T7, T8, T9> {
        Option<Tuple.Tuple9<T1, T2, T3, T4, T5, T6, T7, T8, T9>> id();

        default <R> Option<R> map(Fn9<R, T1, T2, T3, T4, T5, T6, T7, T8, T9> mapper) {
            return id().map(tuple -> tuple.map(mapper));
        }

        default <R> Option<R> flatMap(Fn9<Option<R>, T1, T2, T3, T4, T5, T6, T7, T8, T9> mapper) {
            return id().flatMap(tuple -> tuple.map(mapper));
        }
    }
}
